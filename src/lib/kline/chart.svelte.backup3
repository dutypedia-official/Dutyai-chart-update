<script lang="ts">
  console.log('ðŸ‘‹ Welcome to Duty AI Chart');
  import {page} from '$app/stores';
  import { setContext } from 'svelte';
  import * as kc from 'klinecharts';
  import type {Nullable, IndicatorTemplate, FormatDateType, VisibleRange, Chart} from 'klinecharts'
  import {persisted} from 'svelte-persisted-store';
  import { ChartCtx, ChartSave } from './chart';
  import overlays from './overlays';
  import figures from './figures';
  import indicators from './indicators';
  import MyDatafeed from './mydatafeed';
  import {onMount, onDestroy} from 'svelte';
  import {adjustFromTo, makeFormatDate, setTimezone} from '../dateutil';
  import type {SymbolInfo, Period, BarArr} from './types';
  import DrawBar from './drawBar.svelte';
  import SidebarHost from './SidebarHost.svelte';

  import {browser} from '$app/environment';
  import {getThemeStyles,GetNumberDotOffset, build_ohlcvs, currentSymbol, currentPeriod, processLineChartStyles, convertToHeikinAshi, convertToRenko} from './coms';
  import {tf_to_secs, toUTCStamp} from '../dateutil';
  import { createAlertStore } from '../stores/alerts';
	import Alert from '../alert.svelte';
  import { derived, writable } from 'svelte/store';
  import MenuBar from './menuBar.svelte';
  import ChartModal from '../components/ChartModal.svelte';
  import Toast from '../components/Toast.svelte';
  import type {Writable} from 'svelte/store';
	import _ from 'lodash';
  import { OverlayProjectionManager } from './overlays/overlayProjection';
  import { OverlayEventManager } from '../overlayEventManager';
  import { OverlayCreationManager } from '../overlayCreation';
  import { initializeOverlayAdapter } from './overlays/enhancedOverlayAdapter';
  import { createEnhancedOverlayTemplates } from './overlays/enhancedTemplates';
  import { getSidebarBootstrapState } from '../stores/sidebarBootstrap';
  import { getChartRenderIntegration, getRenderScheduler } from './core';
  import { TransactionalThemeManager } from '../stores/themeManager.js';
  import SaveSystemIntegration from './saveSystem/SaveSystemIntegration.svelte';
  import { initializeDrawingManager, type DrawingManager } from './drawingManager';
  import { PaneMaximizer } from './paneMaximizer';
  import { normalizeSymbolKey } from './saveSystem/chartStateCollector';
  import UnsavedChangesModal from '$lib/UnsavedChangesModal.svelte';
  import { hasUnsavedChanges, unsavedChanges } from '$lib/stores/unsavedChanges';
  import { predictNextCandle, isMarketLikelyClosed } from './candlePredictor';
  setTimezone('UTC')

  const datafeed = new MyDatafeed()
  overlays.forEach(o => kc.registerOverlay(o))
  figures.forEach(f => kc.registerFigure(f))
  indicators.forEach((o: IndicatorTemplate) => {
    if(o.extendData == 'datafeed'){
      o.extendData = datafeed
    }
    kc.registerIndicator(o)
  })
  


  let {
    ctx = writable<ChartCtx>(new ChartCtx()),
    save = persisted('chart', new ChartSave()),
    customLoad=false,
  }: {
    ctx: Writable<ChartCtx>,
    save: Writable<ChartSave>,
    customLoad?: boolean
  } = $props()

  const maxBarNum = 5000;
  if($save.key){
    $save.key = 'chart'
  }
  
  // Ensure allExgs is a Set (persisted store may serialize it as array)
  save.update(s => {
    if (!(s.allExgs instanceof Set)) {
      // Handle case where allExgs might be null, undefined, or not iterable
      const existingData = Array.isArray(s.allExgs) ? s.allExgs : [];
      s.allExgs = new Set(existingData);
    }
    return s;
  });

  let chartRef: HTMLElement
  let drawBarRef = $state<DrawBar>()
  let mainContainerRef = $state<HTMLDivElement>()
  let sidebarHostRef = $state<any>()
  const chart: Writable<Nullable<kc.Chart>> = writable(null)
  const batchNum = 500;
  const alerts = createAlertStore();
  
  // Flag to prevent theme subscription from overriding during manual style application
  let isApplyingManualStyles = false;
  
  // Flag to track initial data load
  let hasInitialDataLoaded = false;
  
  // Infinite scrolling state
  let isLoadingHistoricalData = $state(false);
  let historicalLoadError = $state<string | null>(null);
  // Track if user is pinned to the right edge (latest bars)
  let isPinnedToRight = true;
  // When using Renko, track earliest RAW timestamp fetched so we can request older chunks correctly
  let renkoEarliestRawTs: number | null = null;
  let showUnsavedModal = $state(false);
  // Cleanup reference for infinite scrolling poller
  let infiniteScrollCleanup: (() => void) | null = null;
  // Token to ensure only the latest async load applies (prevents stale data flashing)
  let currentLoadToken = 0;
  function nextLoadToken(): number {
    currentLoadToken += 1;
    return currentLoadToken;
  }
  // Debounce timer for resize handler
  let resizeDebounceTimer: number | null = null;
  let resizeRafId: number | null = null;
  
  /**
   * Window resize handler
   *
   * IMPORTANT:
   * - All chart.resize() calls MUST go through the render scheduler
   *   to keep rendering flickerâ€‘free and DPIâ€‘correct.
   * - We also reapply saved styles + canvas colors after resize, and
   *   force a tiny scroll to trigger a crisp canvas redraw.
   */
  const onWindowResize = () => {
    if (!$chart) return;
    
    // Clear any pending resize operations
    if (resizeDebounceTimer) {
      clearTimeout(resizeDebounceTimer);
      resizeDebounceTimer = null;
    }
    if (resizeRafId) {
      cancelAnimationFrame(resizeRafId);
      resizeRafId = null;
    }
    
    // Stage 1: schedule an immediate resize in the next frame
    resizeRafId = requestAnimationFrame(() => {
      resizeRafId = null;
      scheduler.request(() => {
        if (!$chart) return;
        $chart.resize();
        
        (window as any).__forceApplySavedCanvasColors = true;
        const responsiveStyles = getThemeStyles($save.theme);
        _.merge(responsiveStyles, $state.snapshot($save.styles));
        $chart.setStyles(processLineChartStyles(responsiveStyles));
        applyCanvasColors();
      });
    });
    
    // Stage 2: debounced final resize + forced redraw a bit later
    resizeDebounceTimer = setTimeout(() => {
      resizeDebounceTimer = null;
      
      scheduler.request(() => {
        if (!$chart) return;
        
        // Final resize after layout has fully settled
        $chart.resize();
        
        // Force complete style reapplication using saved styles
        (window as any).__forceApplySavedCanvasColors = true;
        const responsiveStyles = getThemeStyles($save.theme);
        _.merge(responsiveStyles, $state.snapshot($save.styles));
        $chart.setStyles(processLineChartStyles(responsiveStyles));
        applyCanvasColors();
        
        // Force canvas redraw by nudging scroll to the latest bar
        // This prevents the "scaled up / blurry" canvas after big resizes
        const visibleRange = $chart.getVisibleRange?.();
        if (visibleRange && typeof visibleRange.to === 'number') {
          // Use a small delay inside scheduler to let resize commit
          setTimeout(() => {
            if (!$chart) return;
            $chart.scrollToDataIndex(visibleRange.to, 0);
            console.log('ðŸ”„ Forced canvas redraw after window resize to prevent blur');
          }, 30);
        }
      });
    }, 160) as unknown as number;
  };
  
  // Render system integration
  const renderIntegration = getChartRenderIntegration();
  const scheduler = getRenderScheduler();
  
  // Global theme manager instance
  const globalThemeManager = new TransactionalThemeManager('global-chart', chart, $save.theme || 'dark');
  
  // Drawing manager for symbol-specific drawings
  let drawingManager: DrawingManager | null = null;
  let paneMaximizer: PaneMaximizer | null = null;
  
  setContext('ctx', ctx)
  setContext('save', save)
  setContext('chart', chart)
  setContext('alerts', alerts)
  setContext('datafeed', datafeed)
  setContext('renderIntegration', renderIntegration)
  setContext('globalThemeManager', globalThemeManager)
  setContext('drawingManager', { get: () => drawingManager })
  
  // Helper function to generate gradient CSS
  function generateGradientCSS(gradient: any): string {
    if (!gradient) return '';
    
    // Support two formats:
    // 1) { angle, colors: [{ color, position }] }
    // 2) { type, direction, stops: [{ color, position, opacity }] }
    if (Array.isArray(gradient.colors) && gradient.colors.length > 0) {
      const angle = gradient.angle || gradient.direction || 0;
      const colorStops = gradient.colors
        .map((c: any) => `${c.color} ${c.position}%`)
        .join(', ');
      return `linear-gradient(${angle}deg, ${colorStops})`;
    }
    
    if (Array.isArray(gradient.stops) && gradient.stops.length > 0) {
      const type = gradient.type === 'radial' ? 'radial' : 'linear';
      const angle = gradient.direction ?? gradient.angle ?? 0;
      const sortedStops = [...gradient.stops].sort((a: any, b: any) => (a.position ?? 0) - (b.position ?? 0));
      const stopStrings = sortedStops.map((stop: any) => {
        const color = (stop.color || '').trim();
        const pos = stop.position ?? 0;
        const op = (stop.opacity ?? 100) / 100;
        if (color.startsWith('#')) {
          const r = parseInt(color.slice(1, 3), 16);
          const g = parseInt(color.slice(3, 5), 16);
          const b = parseInt(color.slice(5, 7), 16);
          return `rgba(${r}, ${g}, ${b}, ${op}) ${pos}%`;
        }
        if (color.startsWith('rgb(') || color.startsWith('rgba(')) {
          // Append opacity to rgb if needed
          const m = color.match(/rgba?\(([^)]+)\)/i);
          if (m) {
            const parts = m[1].split(',').map((v: string) => v.trim());
            const [r, g, b] = parts;
            return `rgba(${r}, ${g}, ${b}, ${op}) ${pos}%`;
          }
        }
        return `${color} ${pos}%`;
      });
      if (type === 'radial') {
        return `radial-gradient(circle, ${stopStrings.join(', ')})`;
      }
      return `linear-gradient(${angle}deg, ${stopStrings.join(', ')})`;
    }
    
    return '';
  }

  // Helper function to apply saved canvas colors (background and grid)
  function applyCanvasColors() {
    if (!browser) return;
    
    // Set flag to prevent infinite loop
    isApplyingCanvasColors = true;
    
    try {
      // Read directly from $save.styles (reactive) instead of localStorage
      // This ensures we always get the latest values immediately after setting change
      const styles = $save.styles;
      if (!styles) return;
      
      // Apply background color or gradient
      const bgType = styles.backgroundType || 'solid';
      const chartContainer = document.querySelector('.kline-main');
      const chartWidget = document.querySelector('.kline-widget');

      // Preserve any live preview background already set on DOM (via settings modal),
      // unless a theme reset/save-confirm forces saved styles OR a gradient is saved (gradients should always win)
      let existingBgCSS = '';
      const hasSavedGradient = (bgType === 'gradient' && !!styles.backgroundGradient);
      if (!(window as any).__forceApplyThemeDefaults && !(window as any).__forceApplySavedCanvasColors && !hasSavedGradient) {
        const readExistingBg = (el: Element | null) => {
          if (!el) return '';
          const he = el as HTMLElement;
          const computed = window.getComputedStyle(he);
          const varBg = (computed.getPropertyValue('--chart-background-color') || '').trim();
          const inlineBg = (he.style.background || he.style.backgroundColor || '').trim();
          return varBg || inlineBg || '';
        };
        existingBgCSS = readExistingBg(chartContainer) || readExistingBg(chartWidget);
      }

      if (!(window as any).__forceApplyThemeDefaults && !(window as any).__forceApplySavedCanvasColors && !hasSavedGradient && existingBgCSS) {
        // Reapply the existing live preview background to both containers
        [chartContainer, chartWidget].forEach(el => {
          if (el) {
            (el as HTMLElement).style.background = existingBgCSS;
            (el as HTMLElement).style.backgroundColor = existingBgCSS;
            (el as HTMLElement).style.setProperty('--chart-background-color', existingBgCSS);
          }
        });
        console.log('ðŸŽ¨ Preserved live preview background:', existingBgCSS);
      } else if (bgType === 'solid') {
        // Use saved color if available, otherwise use default theme color
        const bgColor = styles.backgroundColor || ($save.theme === 'dark' ? '#070211' : '#ffffff');
        const bgOpacity = (styles.backgroundOpacity ?? 100) / 100;

        // Convert to rgba if needed
        let bgCSS = bgColor;
        if (bgOpacity !== 1 && bgColor.startsWith('#')) {
          const r = parseInt(bgColor.slice(1, 3), 16);
          const g = parseInt(bgColor.slice(3, 5), 16);
          const b = parseInt(bgColor.slice(5, 7), 16);
          bgCSS = `rgba(${r}, ${g}, ${b}, ${bgOpacity})`;
        }

        [chartContainer, chartWidget].forEach(el => {
          if (el) {
            (el as HTMLElement).style.background = bgCSS;
            (el as HTMLElement).style.backgroundColor = bgCSS;
            (el as HTMLElement).style.setProperty('--chart-background-color', bgCSS);
          }
        });

        console.log('ðŸŽ¨ Applied saved background color:', bgCSS);
      } else if (bgType === 'gradient' && styles.backgroundGradient) {
        // Apply gradient background
        const bgGradient = styles.backgroundGradient;
        const gradientCSS = bgGradient.css || generateGradientCSS(bgGradient);

        [chartContainer, chartWidget].forEach(el => {
          if (el) {
            (el as HTMLElement).style.background = gradientCSS;
            (el as HTMLElement).style.backgroundColor = gradientCSS;
            (el as HTMLElement).style.setProperty('--chart-background-color', gradientCSS);
          }
        });

        console.log('ðŸŽ¨ Applied saved gradient background:', gradientCSS);
      }
      
      // Apply grid color or gradient
      const gridType = styles.gridType || 'solid';
      
      // IMPORTANT: Preserve any live preview grid color already applied via $chart.setStyles
      // unless we are forcing theme defaults or a save-confirm wants saved styles.
      if ($chart && gridType === 'solid') {
        const currentStyles = $chart.getStyles?.() ?? {};
        const previewGridColor = ((window as any).__forceApplyThemeDefaults || (window as any).__forceApplySavedCanvasColors)
          ? undefined
          : (_.get(currentStyles, 'grid.horizontal.color') || _.get(currentStyles, 'grid.vertical.color'));
        const savedGridColor = styles.grid?.horizontal?.color || styles.grid?.vertical?.color;
        const defaultGrid = ($save.theme === 'dark' ? '#081115' : '#F3F3F3');
        const gridOpacityPct = typeof styles.gridOpacity === 'number' ? styles.gridOpacity : 100;
        const gridAlpha = Math.max(0, Math.min(100, gridOpacityPct)) / 100;
        let gridColor = previewGridColor || savedGridColor || defaultGrid;
        // If using saved hex and opacity < 1, convert to rgba
        if (!previewGridColor && typeof gridColor === 'string' && gridColor.startsWith('#') && gridAlpha !== 1) {
          const r = parseInt(gridColor.slice(1, 3), 16);
          const g = parseInt(gridColor.slice(3, 5), 16);
          const b = parseInt(gridColor.slice(5, 7), 16);
          gridColor = `rgba(${r}, ${g}, ${b}, ${gridAlpha})`;
        }
        const newStyles = _.cloneDeep(currentStyles);
        
        _.set(newStyles, 'grid.horizontal.color', gridColor);
        _.set(newStyles, 'grid.vertical.color', gridColor);
        
        // Use original setStyles to avoid triggering the wrapper
        if (originalSetStyles) {
          originalSetStyles(processLineChartStyles(newStyles as unknown as Record<string, unknown>));
        } else {
          $chart.setStyles(processLineChartStyles(newStyles as unknown as Record<string, unknown>));
        }
        
        console.log('ðŸŽ¨ Applied grid color (preserving preview when available):', gridColor);
      } else if ($chart && gridType === 'gradient' && styles.gridGradient) {
        // Apply gradient grid (note: grids don't truly support gradients; this uses blended/constructed CSS)
        const currentStyles = $chart.getStyles?.() ?? {};
        const existingColor = ((window as any).__forceApplyThemeDefaults || (window as any).__forceApplySavedCanvasColors)
          ? undefined
          : (_.get(currentStyles, 'grid.horizontal.color') || _.get(currentStyles, 'grid.vertical.color'));
        const gridGradient = styles.gridGradient;
        const gradientCSS = gridGradient.css || generateGradientCSS(gridGradient);
        
        // If an existing grid color is already set (e.g., from a live preview), preserve it
        const appliedColor = existingColor || gradientCSS;
        const newStyles = _.cloneDeep(currentStyles);
        
        _.set(newStyles, 'grid.horizontal.color', appliedColor);
        _.set(newStyles, 'grid.vertical.color', appliedColor);
        
        // Use original setStyles to avoid triggering the wrapper
        if (originalSetStyles) {
          originalSetStyles(processLineChartStyles(newStyles as unknown as Record<string, unknown>));
        } else {
          $chart.setStyles(processLineChartStyles(newStyles as unknown as Record<string, unknown>));
        }
        
        console.log('ðŸŽ¨ Applied gradient grid (preserving preview when available):', appliedColor);
      }
    } catch (error) {
      console.error('Error applying canvas colors:', error);
    } finally {
      // Always reset flag
      isApplyingCanvasColors = false;
      // Consume force flags after one cycle
      if ((window as any).__forceApplyThemeDefaults) {
        (window as any).__forceApplyThemeDefaults = false;
      }
      if ((window as any).__forceApplySavedCanvasColors) {
        (window as any).__forceApplySavedCanvasColors = false;
      }
    }
  }
  
  // Expose applyCanvasColors to context so modals can call it after closing
  $ctx.applyCanvasColors = applyCanvasColors;
  
  // Register applyCanvasColors with render integration to preserve colors during operations
  renderIntegration.setApplyCanvasColorsFunction(applyCanvasColors);
  
  // Register applyCanvasColors with global theme manager to preserve colors during theme switches
  globalThemeManager.setApplyCanvasColorsFunction(applyCanvasColors);
  
  // Create wrapper functions for chart methods that need canvas color reapplication
  let originalChart: kc.Chart | null = null;
  let originalSetStyles: ((styles: any) => any) | null = null;
  let isApplyingCanvasColors = false; // Flag to prevent infinite loop
  
  // Watch for chart changes and wrap its methods
  $effect(() => {
    if ($chart && $chart !== originalChart) {
      originalChart = $chart;
      
      // Store original methods
      originalSetStyles = $chart.setStyles.bind($chart);
      const originalResize = $chart.resize.bind($chart);
      
      // Wrap setStyles to reapply canvas colors after
      ($chart as any).setStyles = function(styles: any) {
        const result = originalSetStyles!(styles);
        // Only reapply canvas colors if NOT already inside applyCanvasColors
        if (!isApplyingCanvasColors) {
          scheduler.request(() => applyCanvasColors());
        }
        return result;
      };
      
      // Wrap resize to reapply canvas colors after
      ($chart as any).resize = function() {
        const result = originalResize();
        // Use scheduler instead of setTimeout for better timing
        scheduler.request(() => applyCanvasColors());
        return result;
      };
      
      console.log('ðŸ”§ Chart methods wrapped to preserve canvas colors');
    }
  });
  


  console.log('ðŸ“Š About to define onMount function');
  console.log('ðŸ“Š Browser environment:', browser);
  
  // Theme is managed centrally in +page.svelte and applied to documentElement.
  // Avoid re-reading localStorage here to prevent racing with persisted store writes
  // that could momentarily revert the theme after a user toggle.
  
  // Try calling loadSymbols immediately regardless of browser environment
  console.log('ðŸš€ Attempting to call loadSymbols immediately');
  loadSymbols().then(() => {
    console.log('âœ… loadSymbols completed successfully');
    console.log('ðŸ“Š allSymbols length:', $save.allSymbols.length);
  }).catch(err => {
    console.error('âŒ loadSymbols failed:', err);
  });
  
  onMount(async () => {
    console.log('ðŸš€ onMount started - browser:', browser);
    console.log('ðŸ“Š chartRef:', chartRef);
    if (!chartRef) {
      console.error('âŒ chartRef is not available');
      return;
    }
    // Get theme styles and merge with saved styles (saved styles should override theme)
    const themeStyles = getThemeStyles($save.theme);
    const mergedStyles = _.merge({}, themeStyles, $save.styles);
    console.log('ðŸŽ¨ onMount - Theme styles:', JSON.stringify(themeStyles, null, 2));
    console.log('ðŸ’¾ onMount - Saved styles:', JSON.stringify($save.styles, null, 2));
    console.log('ðŸ”„ onMount - Merged styles:', JSON.stringify(mergedStyles, null, 2));
    
    $chart = kc.init(chartRef, {
        styles: mergedStyles,
        customApi: {
          formatDate: (timestamp: number, format: string, type: FormatDateType) => {
            return makeFormatDate($save.period.timespan)(timestamp, format, type)
          }
        }
      });
    
    // Initialize overlay system
     if ($chart) {
       const projectionManager = new OverlayProjectionManager($chart);
       const eventManager = new OverlayEventManager($chart);
       const creationManager = new OverlayCreationManager($chart);
       
       // Initialize enhanced overlay adapter
       const overlayAdapter = initializeOverlayAdapter($chart);
       const enhancedTemplates = createEnhancedOverlayTemplates(overlayAdapter);
       
       // Connect the managers
       eventManager.setProjectionManager(projectionManager);
       eventManager.setCreationManager(creationManager);
       
       // Initialize event listeners
       eventManager.initialize();
       
       console.log('Enhanced overlay system initialized with templates:', Object.keys(enhancedTemplates));
       
       // Initialize Drawing Manager for symbol-specific drawings
       drawingManager = initializeDrawingManager({
         chart: $chart,
         persistenceKey: $save.key + '_drawings',
         onDrawingCreated: (drawing) => {
           console.log('âœ… Drawing created:', drawing.id, 'for symbol:', drawing.symbolKey);
         },
         onDrawingRemoved: (drawingId, symbolKey) => {
           console.log('ðŸ—‘ï¸ Drawing removed:', drawingId, 'from symbol:', symbolKey);
         },
         onSymbolChanged: (oldSymbol, newSymbol) => {
           console.log('ðŸ”„ Symbol changed in DrawingManager:', oldSymbol, 'â†’', newSymbol);
         }
       });
       
       // Set current symbol in drawing manager and overlay creation manager
       const currentSymbolKey = normalizeSymbolKey($save.symbol);
       drawingManager.setCurrentSymbol(currentSymbolKey);
       creationManager.setCurrentSymbolKey(currentSymbolKey);
       // Expose for symbol-sync updates
       if (typeof window !== 'undefined') {
         (window as any).overlayCreationManager = creationManager;
       }
       
       console.log('âœ… DrawingManager initialized for symbol:', currentSymbolKey);
     }
    
    // å› æš‚æ—¶ç¦ç”¨äº‘æŒ‡æ ‡ï¼Œæ‰€ä»¥ç›´æŽ¥è§¦å‘å®Œæˆ
    $ctx.cloudIndLoaded += 1
    
    // Initialize current symbol and period stores
    currentSymbol.set($save.symbol);
    currentPeriod.set($save.period);
    
    // Load symbols on mount
    console.log('ðŸš€ About to call loadSymbols from onMount');
    await loadSymbols();
    console.log('âœ… loadSymbols completed from onMount');
    
    window.addEventListener('resize', onWindowResize)
    let chartObj = $chart!;
    
    // Set default chart view without excessive zoom
    setTimeout(() => {
      if (chartObj) {
        // Scroll to show latest data (right side)
        chartObj.scrollToRealTime();
      }
    }, 100);
    // Implement infinite scrolling for historical data loading
    // Since setLoadMoreDataCallback is not available in klinecharts v9.x,
    // we'll implement scroll detection manually
    // Ensure previous poller (if any) is cleaned before starting a new one
    if (infiniteScrollCleanup) {
      try { infiniteScrollCleanup(); } catch {}
      infiniteScrollCleanup = null;
    }
    infiniteScrollCleanup = setupInfiniteScrolling(chartObj);
    const styles = getThemeStyles($save.theme)
    _.merge(styles, $state.snapshot($save.styles))
    $chart?.setStyles(processLineChartStyles(styles))
    
    // CRITICAL FIX: Apply saved canvas colors immediately after chart initialization
    // This ensures custom colors are applied on first load without requiring settings click
    console.log('ðŸŽ¨ APPLYING SAVED CANVAS COLORS ON FIRST LOAD');
    applyCanvasColors();
    
    // ADDITIONAL FIX: Apply canvas colors again after a short delay to ensure they stick
    // This handles cases where the chart might override colors during initial setup
    setTimeout(() => {
      console.log('ðŸŽ¨ RE-APPLYING SAVED CANVAS COLORS AFTER DELAY');
      applyCanvasColors();
    }, 200);
    
    // Restore saved indicators on refresh so they remain visible and selected
    try {
      const restoreIndicatorsFromSave = () => {
        if (!$chart) return;
        const chartObj = $chart;
        let existing: Array<{ name: string; paneId?: string }>=[];
        try {
          existing = (chartObj.getIndicators?.() ?? []) as Array<{ name: string; paneId?: string }>;
        } catch (_) {
          existing = [];
        }

        const entries = Object.entries($save.saveInds || {});
        for (const [, ind] of entries) {
          const name = ind?.name;
          if (!name) continue;

          const paneId = ind?.pane_id || '';
          const alreadyExists = existing.some(e => e.name === name && (!paneId || e.paneId === paneId));
          if (alreadyExists) continue;

          // Convert saved line styles (if any) to klinecharts styles
          let styles: any | undefined = undefined;
          if (Array.isArray(ind.styles) && ind.styles.length > 0) {
            const convert = (style: string | undefined) => {
              if (style === 'dashed' || style === 'dotted') {
                return { style: kc.LineType.Dashed, dashedValue: style === 'dotted' ? [2, 2] : [4, 4] };
              }
              return { style: kc.LineType.Solid, dashedValue: [2, 2] };
            };
            styles = {
              lines: ind.styles.map((s: any) => {
                const lt = convert(s?.lineStyle);
                return {
                  color: s?.color,
                  size: s?.thickness ?? 1,
                  style: lt.style,
                  dashedValue: lt.dashedValue
                };
              })
            };
          }
          
          // Prepare extendData for SUPERTREND (Smart Trend) so per-segment styles are respected
          let extendData: any | undefined = undefined;
          if (name === 'SUPERTREND') {
            const group: any = (ind as any).superTrendGroup;
            extendData = group ? {
              showLabels: Boolean(group.showLabels),
              uptrendColor: group.styles?.uptrend?.color ?? '#00FF00',
              downtrendColor: group.styles?.downtrend?.color ?? '#FF0000',
              uptrendThickness: group.styles?.uptrend?.thickness ?? 1,
              downtrendThickness: group.styles?.downtrend?.thickness ?? 1,
              uptrendLineStyle: group.styles?.uptrend?.lineStyle ?? 'dashed',
              downtrendLineStyle: group.styles?.downtrend?.lineStyle ?? 'dashed'
            } : {
              showLabels: true,
              uptrendColor: '#00FF00',
              downtrendColor: '#FF0000',
              uptrendThickness: 1,
              downtrendThickness: 1,
              uptrendLineStyle: 'dashed',
              downtrendLineStyle: 'dashed'
            };
            // If no explicit styles were saved, ensure base line looks dashed by default
            if (!styles) {
              const upDashed = extendData.uptrendLineStyle === 'dotted' || extendData.uptrendLineStyle === 'dashed';
              styles = {
                lines: [{
                  color: extendData.uptrendColor,
                  size: extendData.uptrendThickness,
                  style: upDashed ? kc.LineType.Dashed : kc.LineType.Solid,
                  dashedValue: extendData.uptrendLineStyle === 'dotted' ? [2, 2] : [4, 4]
                }]
              };
            }
          }

          const isMain = paneId === 'candle_pane';
          try {
            chartObj.createIndicator({
              name,
              calcParams: ind?.params,
              styles,
              ...(extendData ? { extendData } : {})
            }, isMain, paneId ? { id: paneId } : undefined);
          } catch (err) {
            console.warn('âš ï¸ Failed to restore indicator:', name, err);
          }
        }
      };

      // Decide restoration strategy based on active saved layout
      let activeSaveId: string | null = null;
      try {
        activeSaveId = (typeof window !== 'undefined') ? localStorage.getItem('chart.activeSaveId') : null;
      } catch {}
      
      // IMPORTANT: Never restore from $save.saveInds (these are cached unsaved changes)
      // Only SaveSystem should restore indicators from saved layouts
      // If no saved layout exists, we'll add default indicators below
      if (activeSaveId) {
        console.log('â„¹ï¸ Active layout detected, SaveSystem will restore indicators.');
      } else {
        console.log('â„¹ï¸ No active layout, will add default indicators if needed.');
      }

      // Helper to add default indicators
      // This is called only when there's NO saved layout
      const addDefaultIndicators = (force: boolean) => {
        try {
          if (!$chart) return;
          const chartObj = $chart;
          
          // When force=true, always add defaults
          // When force=false, check if indicators already exist
          if (!force) {
            let existing: Array<{ name: string; paneId?: string }> = [];
            try {
              existing = (chartObj.getIndicators?.() ?? []) as Array<{ name: string; paneId?: string }>;
            } catch {}
            if (existing && existing.length > 0) {
              console.log('â„¹ï¸ Indicators already exist, skipping defaults');
              return;
            }
          }
          
          console.log('ðŸŽ¨ Adding default indicators...');
          
          const mainPaneId = 'candle_pane';
          // SuperTrend
          try {
            const indId = chartObj.createIndicator({
              name: 'SUPERTREND',
              calcParams: [10, 3.0],
              // Base style; per-trend style is controlled via extendData in draw
              styles: {
                lines: [{
                  color: '#00FF00',
                  size: 1,
                  style: kc.LineType.Dashed,
                  dashedValue: [4, 4]
                }]
              },
              extendData: {
                showLabels: true,
                uptrendColor: '#00FF00',    // lime
                downtrendColor: '#FF0000',  // red
                uptrendThickness: 1,
                downtrendThickness: 1,
                uptrendLineStyle: 'dashed',
                downtrendLineStyle: 'dashed'
              }
            }, true, { id: mainPaneId });
            if (indId) {
              save.update(s => {
                s.saveInds[`${mainPaneId}_SUPERTREND`] = {
                  name: 'SUPERTREND',
                  pane_id: mainPaneId,
                  params: [10, 3.0]
                };
                return s;
              });
            }
          } catch {}
          
          // Volume on main pane (TradingView style) - no extra sub pane
          try {
            const volPaneId = 'candle_pane';
            const indId = chartObj.createIndicator({
              name: 'VOL',
              calcParams: [20],
              // Set EMA line visibility off by default
              styles: {
                lines: [{
                  visible: false
                }]
              }
            }, true, { id: volPaneId });
            if (indId) {
              save.update(s => {
                s.saveInds[`${volPaneId}_VOL`] = {
                  name: 'VOL',
                  pane_id: volPaneId,
                  params: [20]
                };
                return s;
              });
            }
          } catch {}
          
          console.log('âœ… Default indicators applied', { force });
        } catch (err) {
          console.warn('âš ï¸ Failed to add default indicators:', err);
        }
      };
      
      // Detect browser reload navigation
      let isReload = false;
      try {
        const navEntries = (performance as any).getEntriesByType?.('navigation');
        if (navEntries && navEntries.length > 0) {
          isReload = navEntries[0].type === 'reload';
        } else if ((performance as any).navigation) {
          isReload = ((performance as any).navigation.type === 1);
        }
      } catch {}
      
      // CRITICAL FIX: Always clear cached unsaved indicators
      // Only saved layouts should persist, not ad-hoc changes
      save.update(s => {
        s.saveInds = {}; // Clear unsaved indicator cache
        return s;
      });
      
      if (activeSaveId) {
        // Active saved layout exists - SaveSystem will restore it
        console.log('âœ… Active saved layout will be restored by SaveSystem');
      } else {
        // No saved layout - add default indicators
        console.log('ðŸŽ¨ No saved layout found, adding default indicators');
        setTimeout(() => addDefaultIndicators(true), 250);
      }
    } catch (e) {
      console.warn('âš ï¸ Indicator restore failed:', e);
    }

    $ctx.initDone += 1
    
    // Load initial data with a delay to ensure chart is fully initialized
    if (!customLoad) {
      setTimeout(() => {
        if ($chart && !$ctx.loadingKLine) {
          console.log('ðŸ”„ Loading initial chart data after initialization');
          loadSymbolPeriod();
          hasInitialDataLoaded = true;
        }
      }, 100);
    }
    
    loadSymbols();
    
    // Debug: Check symbols in browser console
    setTimeout(() => {
      console.log('ðŸ” Current allSymbols:', $save.allSymbols);
      console.log('ðŸ” allSymbols length:', $save.allSymbols.length);
    }, 3000);
    
    // Focus the chart widget to enable keyboard events
    chartRef?.focus();
    // Expose draw bar instance globally for overlay event forwarding
    try {
      if (typeof window !== 'undefined') {
        (window as any).drawBarRef = drawBarRef;
        // Expose predictNextCandle function and state globally for menuBar access
        (window as any).predictNextCandle = () => handleWhatNext();
        (window as any).getAutoPlayState = () => isAutoPlaying;
        (window as any).getPlaybackSpeed = () => playbackSpeed;
        (window as any).setPlaybackSpeed = (speed: number) => changeSpeed(speed);
        (window as any).stopPrediction = () => stopAutoPlay();
      }
    } catch {}

    // Intercept refresh keys when there are unsaved changes (F5, Cmd/Ctrl+R)
    const onKeyDown = (e: KeyboardEvent) => {
      if (!hasUnsavedChanges()) return;
      const isRefreshKey = e.key === 'F5' || ((e.metaKey || e.ctrlKey) && (e.key === 'r' || e.key === 'R'));
      if (isRefreshKey) {
        e.preventDefault();
        e.stopPropagation();
        showUnsavedModal = true;
      }
    };
    window.addEventListener('keydown', onKeyDown, { capture: true });

    // Fallback: native browser prompt when clicking the browser reload button
    const onBeforeUnload = (e: BeforeUnloadEvent) => {
      if (hasUnsavedChanges()) {
        // Proactively clear any unsaved drawing stores so they won't rehydrate after reload
        try {
          // 1) DrawingManager persisted store
          const dmKey = ($save?.key || 'chart') + '_drawings';
          localStorage.removeItem(dmKey);
        } catch {}
        try {
          // 2) Legacy overlays persisted store used by drawBar
          const overlaysKey = ($save?.key || 'chart') + '_overlays';
          localStorage.removeItem(overlaysKey);
        } catch {}
        try {
          // 3) Data-space overlays cache
          localStorage.removeItem('dataSpaceOverlays');
        } catch {}
        
        e.preventDefault();
        e.returnValue = '';
      }
    };
    window.addEventListener('beforeunload', onBeforeUnload);

    // Cleanup listeners on destroy
    onDestroy(() => {
      // Stop auto-play if running
      stopAutoPlay();
      
      // Cleanup resize timers to prevent memory leaks
      if (resizeDebounceTimer) {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = null;
      }
      if (resizeRafId) {
        cancelAnimationFrame(resizeRafId);
        resizeRafId = null;
      }
      
      window.removeEventListener('keydown', onKeyDown, { capture: true } as any);
      window.removeEventListener('beforeunload', onBeforeUnload);
      try { window.removeEventListener('resize', onWindowResize) } catch {}
      if (infiniteScrollCleanup) {
        try { infiniteScrollCleanup(); } catch {}
        infiniteScrollCleanup = null;
      }
    });
    
    // Enhanced separator interaction functionality
    setTimeout(() => {
      const separators = chartRef?.querySelectorAll('.klinecharts-pane-separator');
      separators?.forEach((separator) => {
        const element = separator as HTMLElement;
        
        // Add smooth cursor feedback
        element.style.transition = 'background-color 0.2s ease, transform 0.1s ease';
        
        // Enhanced mouse events for desktop
        element.addEventListener('mouseenter', () => {
          element.style.cursor = 'row-resize';
          element.style.transform = 'scaleY(1.2)';
        });
        
        element.addEventListener('mouseleave', () => {
          element.style.transform = 'scaleY(1)';
        });
        
        // Add dragging class for visual feedback
        element.addEventListener('mousedown', () => {
          element.classList.add('dragging');
          document.body.style.cursor = 'row-resize';
        });
        
        // Remove dragging class on mouse up (global)
        const handleMouseUp = () => {
          element.classList.remove('dragging');
          document.body.style.cursor = '';
        };
        
        document.addEventListener('mouseup', handleMouseUp);
        
        // Enhanced touch support for mobile
        element.addEventListener('touchstart', (e) => {
          e.preventDefault();
          element.classList.add('dragging');
          // Add haptic feedback if available
          if ('vibrate' in navigator) {
            navigator.vibrate(10);
          }
        });
        
        element.addEventListener('touchend', () => {
          element.classList.remove('dragging');
        });
      });
    }, 500); // Delay to ensure chart is fully rendered
  })

  // Setup infinite scrolling for historical data loading
  function setupInfiniteScrolling(chartObj: kc.Chart) {
    let lastVisibleRange: VisibleRange | null = null;
    let isLoadingHistorical = false;
    let lastLoadTime = 0;
    const loadCooldown = 800; // Reduced to 800ms for faster loading
    let consecutiveLoadCount = 0;
    const maxConsecutiveLoads = 5; // Allow more consecutive loads
    // Track visible bars to detect zoom vs pan
    let lastVisibleBars: number | null = null;
    // Stop further requests once we reach the start of history
    let reachedHistoricalStart = false;
    
    // Poll for scroll changes with optimized logic
    const checkScrollPosition = () => {
      try {
        if (reachedHistoricalStart) return;
        const visibleRange = chartObj.getVisibleRange();
        
        if (!visibleRange || isLoadingHistorical) return;
        
        const dataList = chartObj.getDataList();
        if (dataList.length === 0) return;
        // Update right-edge pin status: if rightmost visible index is near the last bar, consider pinned
        const lastIndex = dataList.length - 1;
        const rightThreshold = 1; // allow a tiny buffer
        isPinnedToRight = visibleRange.to >= (lastIndex - rightThreshold);
        
        // More aggressive threshold for faster loading
        const visibleBars = visibleRange.to - visibleRange.from;
        // Track last visible bars (for potential future heuristics)
        lastVisibleBars = visibleBars;
        const scrollThreshold = Math.max(3, Math.min(15, Math.floor(visibleBars * 0.15))); // 15% of visible range, min 3, max 15
        
        // Check if user scrolled to the left edge (need more historical data)
        const isScrollingLeft = lastVisibleRange && visibleRange.from < lastVisibleRange.from;
        // Near-left detection using dynamic threshold (pan near edge)
        const isNearLeftEdge = visibleRange.from <= scrollThreshold;
        const hasSignificantMovement = !lastVisibleRange || Math.abs(visibleRange.from - lastVisibleRange.from) > 1; // Reduced movement threshold
        
        // Adaptive cooldown - slow down but don't stop completely
        const now = Date.now();
        const adaptiveCooldown = consecutiveLoadCount >= maxConsecutiveLoads ? loadCooldown * 3 : loadCooldown;
        const canLoad = now - lastLoadTime > adaptiveCooldown;
        
        // More aggressive loading conditions
        const isVeryNearEdge = visibleRange.from <= Math.max(1, Math.floor(scrollThreshold / 2)); // closer to absolute edge
        // Load whenever left edge hits the boundary, regardless of zoom; rely on cooldown
        const shouldLoadAggressively = isVeryNearEdge && canLoad;
        const shouldLoadNormally = isNearLeftEdge && canLoad;
        
        if (shouldLoadAggressively || shouldLoadNormally) {
          const firstDataPoint = dataList[0];
          console.log(`ðŸš€ Infinite scroll triggered: from=${visibleRange.from}, threshold=${scrollThreshold}, dataLength=${dataList.length}, consecutive=${consecutiveLoadCount}`);
          loadMoreHistoricalData(firstDataPoint.timestamp);
          lastLoadTime = now;
          consecutiveLoadCount++;
          
          // Reset consecutive count gradually
          setTimeout(() => {
            consecutiveLoadCount = Math.max(0, consecutiveLoadCount - 1);
          }, loadCooldown * 1.5);
        }
        
        lastVisibleRange = { ...visibleRange }; // Create a copy to avoid reference issues
      } catch (error) {
        console.error('âŒ Error checking scroll position:', error);
      }
    };
    
    // Load more historical data when scrolling left
    const loadMoreHistoricalData = async (earliestTimestamp: number) => {
      if (isLoadingHistorical || $ctx.loadingKLine || isLoadingHistoricalData) {
        console.log('â³ Already loading data, skipping request...');
        return;
      }
      
      isLoadingHistorical = true;
      isLoadingHistoricalData = true;
      historicalLoadError = null;
      console.log('ðŸ”„ Loading more historical data...');
      
      try {
        // For Renko, use earliest RAW timestamp window rather than brick timestamp
        const isRenko = $save.styles?.candle?.type === 'renko_atr';
        const rawBoundary = isRenko ? (renkoEarliestRawTs ?? earliestTimestamp) : earliestTimestamp;
        const newData = await datafeed.loadMoreHistoricalData($save.symbol, $save.period, rawBoundary);
        
        if (newData.data.length > 0) {
          // Apply chart-type specific transformations if needed
          let klines = newData.data;
          if ($save.styles?.candle?.type === 'heikin_ashi') {
            klines = convertToHeikinAshi(klines);
          } else if ($save.styles?.candle?.type === 'renko_atr') {
            const renkoCfg = ($save.styles as any)?.candle?.renko || { method: 'ATR', atrLength: 14, source: 'close', wick: false };
            klines = convertToRenko(klines, renkoCfg);
            // Update earliest RAW boundary for next fetch
            try {
              const minTs = newData.data && newData.data.length ? Math.min(...newData.data.map((d: any) => d.timestamp || 0)) : null;
              if (minTs && (!renkoEarliestRawTs || minTs < renkoEarliestRawTs)) {
                renkoEarliestRawTs = minTs;
              }
            } catch {}
          }
          
          // Get current data and merge properly
          const currentData = chartObj.getDataList();
          
          // Sort new data by timestamp (oldest first)
          klines.sort((a, b) => a.timestamp - b.timestamp);
          
          // Filter out any duplicates based on timestamp
          const existingTimestamps = new Set(currentData.map(d => d.timestamp));
          const uniqueNewData = klines.filter(d => !existingTimestamps.has(d.timestamp));
          
          if (uniqueNewData.length > 0) {
            // Store current scroll position and viewport info before adding new data
            const currentVisibleRange = chartObj.getVisibleRange();
            
            // Store the timestamp of the first visible bar to maintain relative position
            const firstVisibleTimestamp = currentVisibleRange && currentData[currentVisibleRange.from] 
              ? currentData[currentVisibleRange.from].timestamp 
              : null;
            
            // Merge data: new historical data first, then existing data
            const mergedData = [...uniqueNewData, ...currentData].sort((a, b) => a.timestamp - b.timestamp);
            
            // Apply the merged data to the chart without forcing right alignment
            chartObj.applyNewData(mergedData, false);
            
            console.log(`âœ… Successfully loaded and merged ${uniqueNewData.length} more historical bars`);
            
            // Clear any previous errors
            historicalLoadError = null;
            
            // Preserve scroll position using multiple strategies for better accuracy
            if (currentVisibleRange && firstVisibleTimestamp) {
              // Strategy 1: Find the new index of the previously visible timestamp
              const newIndexOfFirstVisible = mergedData.findIndex(d => d.timestamp === firstVisibleTimestamp);
              
              if (newIndexOfFirstVisible !== -1) {
                // Defer scroll adjustment to next frame to avoid jump
                try {
                  requestAnimationFrame(() => {
                    try {
                      chartObj.scrollToDataIndex(newIndexOfFirstVisible);
                      console.log(`ðŸŽ¯ Scroll position adjusted to index ${newIndexOfFirstVisible} (was ${currentVisibleRange.from})`);
                    } catch {}
                  });
                } catch (_error) {
                  // Fallback: Use the simple offset method
                  const fallbackIndex = currentVisibleRange.from + uniqueNewData.length;
                  try {
                    chartObj.scrollToDataIndex(fallbackIndex);
                    console.log(`ðŸ”„ Fallback scroll to index ${fallbackIndex}`);
                  } catch (fallbackError) {
                    console.warn('Could not maintain scroll position:', fallbackError);
                  }
                }
              } else {
                // Fallback: Use offset method if timestamp lookup fails
                const offsetIndex = currentVisibleRange.from + uniqueNewData.length;
                try {
                  requestAnimationFrame(() => {
                    try { chartObj.scrollToDataIndex(offsetIndex); } catch {}
                  });
                  console.log(`ðŸ“ Offset scroll to index ${offsetIndex}`);
                } catch (error) {
                  console.warn('Could not maintain scroll position:', error);
                }
              }
            }
          } else {
            console.log('ðŸ“­ No new unique historical data to add');
          }
          
          // Add any overlays if present
          if (newData.lays && newData.lays.length > 0 && drawBarRef) {
            newData.lays.forEach(o => {
              drawBarRef!.addOverlay(o);
            });
          }
        } else {
          console.log('ðŸ“­ No more historical data available');
          // Prevent further polling for historical data
          reachedHistoricalStart = true;
        }
      } catch (error) {
        console.error('âŒ Error loading more historical data:', error);
        historicalLoadError = error instanceof Error ? error.message : 'Failed to load historical data';
        
        // Show error alert to user
        alerts.addAlert('error', `Failed to load historical data: ${historicalLoadError}`);
      } finally {
        isLoadingHistorical = false;
        isLoadingHistoricalData = false;
      }
    };
    
    // Start polling for scroll changes with high frequency for fast response
    const scrollCheckInterval = setInterval(checkScrollPosition, 100); // Check every 100ms for faster response
    
    // Cleanup function (store reference for cleanup if needed)
    return () => {
      clearInterval(scrollCheckInterval);
      console.log('ðŸ§¹ Infinite scrolling cleanup completed');
    };
  }

  async function loadSymbols(){
    console.log('ðŸš€ loadSymbols function called. loadingPairs:', $ctx.loadingPairs, 'allSymbols length:', $save.allSymbols.length);
    // Force load symbols by bypassing condition temporarily
    // if($ctx.loadingPairs || $save.allSymbols.length > 0)return;
    $ctx.loadingPairs = true;
    console.log('ðŸ”„ Loading symbols...');
    console.log('ðŸ”„ loadSymbols proceeding');
    const symbols = await datafeed.getSymbols();
    console.log('ðŸ“Š Symbols loaded:', symbols);
    console.log('ðŸ“Š Symbols loaded count:', symbols.length);
    $save.allSymbols = symbols;
    const exgs = new Set<string>();
    symbols.forEach(s => {
      if (s.exchange){
        exgs.add(s.exchange)
      }
    })
    save.update(s => {
      exgs.forEach(e => {
        s.allExgs.add(e)
      })
      return s
    })
    $ctx.loadingPairs = false;
  }
  
  async function loadKlineRange(symbol: SymbolInfo, period: Period, start_ms: number, stop_ms: number,
                              loadMore: boolean = true, expectedToken: number = currentLoadToken) {
    const chartObj = $chart;
    if (!chartObj) return
    if (expectedToken === currentLoadToken) {
      $ctx.loadingKLine = true
    }
    const strategy = $page.url.searchParams.get('strategy');
    console.log('loadKlineRange', {symbol, period, start_ms, stop_ms, strategy})
    const kdata = await datafeed.getHistoryKLineData({
      symbol, period, from: start_ms, to: stop_ms, strategy
    })
    let klines = kdata.data
    

    
    // Apply chart-type specific transformations
    if ($save.styles?.candle?.type === 'heikin_ashi') {
      klines = convertToHeikinAshi(klines);
    } else if ($save.styles?.candle?.type === 'renko_atr') {
      // Update earliest RAW timestamp window for infinite scroll
      try {
        const minTs = kdata.data && kdata.data.length ? Math.min(...kdata.data.map((d: any) => d.timestamp || 0)) : null;
        if (minTs && (!renkoEarliestRawTs || minTs < renkoEarliestRawTs)) {
          renkoEarliestRawTs = minTs;
        }
      } catch {}
      const renkoCfg = ($save.styles as any)?.candle?.renko || { method: 'ATR', atrLength: 14, source: 'close', wick: false };
      klines = convertToRenko(klines, renkoCfg);
    }
    
    // Validate timestamps before applying to chart
    klines = klines.map((kline, index) => {
      if (!kline.timestamp || isNaN(kline.timestamp) || kline.timestamp <= 0) {
        console.warn(`Invalid timestamp in klines at index ${index}:`, kline.timestamp);
        kline.timestamp = Date.now() - (klines.length - index) * 60000; // Use fallback with proper spacing
      }
      return kline;
    });
    
    // Ignore stale responses if a newer load has started
    if (expectedToken !== currentLoadToken) {
      console.log('â­ï¸ Ignoring stale load result');
      return;
    }
    const isRenko = $save.styles?.candle?.type === 'renko_atr';
    const hasMore = !isRenko && (loadMore && klines.length > 0);
    chartObj.applyNewData(klines, !!hasMore);
    if(kdata.lays && kdata.lays.length > 0 && !!drawBarRef){
      kdata.lays.forEach(o => {
        drawBarRef!.addOverlay(o)
      })
    }
    if (expectedToken === currentLoadToken) {
      $ctx.loadingKLine = false
    }
    // è§¦å‘Kçº¿åŠ è½½å®Œæ¯•äº‹ä»¶
    $ctx.klineLoaded += 1
    if (klines.length) {
      const tf_msecs = tf_to_secs(period.timeframe) * 1000
      const curTime = new Date().getTime()
      const stop_ms = klines[klines.length - 1].timestamp + tf_msecs
      if (!isRenko && (stop_ms + tf_msecs > curTime)) {
        // åŠ è½½çš„æ˜¯æœ€æ–°çš„barï¼Œåˆ™è‡ªåŠ¨å¼€å¯websocketç›‘å¬
        datafeed.subscribe(symbol, (param: unknown) => {
          const result = param as { bars: BarArr[], secs: number };
          const kline = chartObj.getDataList()
          const last = kline[kline.length - 1]
          const lastBar: BarArr | null = last && last.timestamp ? [
            last.timestamp, last.open, last.high, last.low, last.close, last.volume ?? 0
          ] : null
          const ohlcvArr = build_ohlcvs(result.bars, result.secs * 1000, tf_msecs, lastBar)
          const store = (chartObj as Chart & { getChartStore(): any }).getChartStore()
          // Capture current viewport and compute pinned state in real-time
          const preVisibleRange = chartObj.getVisibleRange();
          const preData = chartObj.getDataList();
          const preFirstVisibleTs = preVisibleRange && preData[preVisibleRange.from]
            ? preData[preVisibleRange.from].timestamp
            : null;
          const lastIndexNow = preData.length - 1;
          const pinnedNow = preVisibleRange ? (preVisibleRange.to >= (lastIndexNow - 1)) : true;
          // Append new ticks; only advance if pinned at this exact moment
          store.addData(ohlcvArr, 'backward', {forward: pinnedNow, backward:false})
          // Restore viewport when not pinned
          if (!pinnedNow && preVisibleRange && preFirstVisibleTs) {
            requestAnimationFrame(() => {
              try {
                const postData = chartObj.getDataList();
                const newIndex = postData.findIndex(d => d.timestamp === preFirstVisibleTs);
                if (newIndex !== -1) {
                  chartObj.scrollToDataIndex(newIndex);
                } else {
                  chartObj.scrollToDataIndex(preVisibleRange.from);
                }
              } catch (_e) {}
            });
          }
        })
      }
    }
  }

  async function customLoadKline(){
    const start_ms = toUTCStamp($save.dateStart)
    let stop_ms = toUTCStamp($save.dateEnd)
    if(!start_ms || !stop_ms){
      alerts.addAlert('error', 'invalid time, please use: 202301011200')
      return;
    }
    const tf_msecs = tf_to_secs($save.period.timeframe) * 1000
    const totalNum = (stop_ms - start_ms) / tf_msecs;
    if(totalNum > maxBarNum){
      stop_ms = start_ms + tf_msecs * maxBarNum;
      // Silently cut the data range without showing alert
    }
    await loadKlineRange($save.symbol, $save.period, start_ms, stop_ms, false)
  }

  function loadSymbolPeriod(expectedToken?: number){
    console.log('ðŸ”„ loadSymbolPeriod called');
    const s = $save.symbol
    const p = $save.period
    console.log('ðŸ”„ Loading symbol:', s.ticker, 'period:', p.timeframe);
    const curTime = new Date().getTime()
    const [from, to] = adjustFromTo(p, curTime, batchNum)
    console.log('ðŸ”„ Time range:', new Date(from), 'to', new Date(curTime));
    loadKlineRange(s, p, from, curTime, !customLoad, expectedToken ?? currentLoadToken)
  }

  // ç›‘å¬å‘¨æœŸå˜åŒ– (Timeframe changes) - with flicker-free rendering
  const period = derived(save, ($save) => $save.period.timeframe);
  period.subscribe((new_tf) => {
    try {
      $chart?.setCustomApi({
        formatDate: (timestamp: number, format: string, type: FormatDateType) => {
          return makeFormatDate($save.period.timespan)(timestamp, format, type)
        }
      })
    } catch (e) {
      // API compatibility issue with v9
    }
    
    // Update global period store for tooltip display
    currentPeriod.set($save.period);
    
    // Reset renko earliest boundary when timeframe changes
    renkoEarliestRawTs = null;
    
    if (customLoad || !$chart) return
    
    // Use render integration for flicker-free timeframe change
    renderIntegration.changeTimeframe({
      chart: $chart,
      period: $save.period,
      loadDataFn: async () => {
        const token = nextLoadToken();
        // Clear chart data immediately to avoid stale view while loading new TF
        try { $chart?.applyNewData([], false); } catch {}
        await loadSymbolPeriod(token);
      }
    });

    // Restart infinite scrolling when timeframe changes so historical loading
    // state (e.g. reachedHistoricalStart) is reset for the new timeframe.
    // Without this, if a previous timeframe had already hit the history start,
    // new timeframes could stop loading older candles even when you scroll left.
    if (infiniteScrollCleanup) {
      try { infiniteScrollCleanup(); } catch {}
      infiniteScrollCleanup = null;
    }
    if ($chart) {
      infiniteScrollCleanup = setupInfiniteScrolling($chart);
    }
  })
  
  // ç›‘å¬å¸ç§å˜åŒ–
  const symbol = derived(save, ($save) => $save.symbol.ticker);
  symbol.subscribe((val) => {
    console.log('ðŸ“Š Symbol subscription triggered:', val);
    console.log('ðŸ“Š Current symbol:', $save.symbol);
    console.log('ðŸ“Š Loading state:', $ctx.loadingKLine, 'Custom load:', customLoad);
    // Update global symbol store for tooltip
    currentSymbol.set($save.symbol);
    // Reset renko earliest boundary when symbol changes
    renkoEarliestRawTs = null;
    
    // Update DrawingManager with new symbol
    if (drawingManager) {
      const newSymbolKey = normalizeSymbolKey($save.symbol);
      drawingManager.setCurrentSymbol(newSymbolKey);
      console.log('ðŸ”„ DrawingManager updated to symbol:', newSymbolKey);
      // Ensure overlays for current symbol are rendered immediately
      drawingManager.renderCurrentSymbolDrawings();
    }
    // Keep OverlayCreationManager in sync so new drawings get correct symbolKey
    try {
      // creationManager is scoped inside init block; retrieve via window if exposed
      const overlayCreation = (window as any).overlayCreationManager as OverlayCreationManager | undefined;
      if (overlayCreation) {
        overlayCreation.setCurrentSymbolKey(normalizeSymbolKey($save.symbol));
      }
    } catch {
    }
    
    if (customLoad) return
    console.log('ðŸ“Š Proceeding with symbol change - unsubscribing and loading new data');
    // Stop any streaming and clear caches to avoid stale data artifacts
    datafeed.unsubscribe()
    try { datafeed.clearCache(); } catch {}
    // Clear current chart data immediately for responsive visual feedback
    try { $chart?.applyNewData([], false); } catch {}
    // Restart infinite scroll poller for new symbol
    if (infiniteScrollCleanup) {
      try { infiniteScrollCleanup(); } catch {}
      infiniteScrollCleanup = null;
    }
    if ($chart) {
      infiniteScrollCleanup = setupInfiniteScrolling($chart);
    }
    const token = nextLoadToken();
    loadSymbolPeriod(token)
  })

  // ç›‘å¬ä¸»é¢˜å˜åŒ–
  const theme = derived(save, ($save) => $save.theme);
  let previousTheme = $save.theme;
  theme.subscribe((new_val) => {
    console.log('ðŸŽ¨ THEME SUBSCRIPTION TRIGGERED:', new_val, 'Previous:', previousTheme)
    
    // Only proceed if theme actually changed
    if (new_val === previousTheme) {
      console.log('â¸ï¸ Theme value unchanged, skipping subscription')
      return
    }
    
    console.log('ðŸŽ¨ THEME ACTUALLY CHANGED:', previousTheme, '->', new_val)
    previousTheme = new_val
    
    // Skip if we're manually applying styles to prevent override
    if (isApplyingManualStyles) {
      console.log('â¸ï¸ Skipping theme subscription - manual styles being applied')
      return
    }
    
    // Check context flag as well
    if ($ctx.isApplyingManualStyles) {
      console.log('â¸ï¸ SKIPPING theme application - manual styles are being applied via context')
      return
    }
    
    // åŠ è½½æ–°æŒ‡æ ‡æ—¶ï¼Œä¿®æ”¹é»˜è®¤é¢œè‰²
    if(new_val == 'light'){
      $save.colorLong = 'green'
      $save.colorShort = 'red'
    }
    else{
      $save.colorLong = 'green'
      $save.colorShort = 'rgb(255,135,8)'
    }
    const styles = getThemeStyles($save.theme)
    console.log('ðŸŽ¨ Theme styles from getThemeStyles:', JSON.stringify(styles, null, 2))
    console.log('ðŸ’¾ Current save.styles:', JSON.stringify($save.styles, null, 2))
    
    // CRITICAL: Preserve chart type from $save.styles before merging
    const savedStyles = $state.snapshot($save.styles);
    const preservedChartType = savedStyles?.candle?.type;
    if (preservedChartType) {
      console.log('ðŸ”’ Preserving chart type during theme change:', preservedChartType);
    }
    
    const mergedStyles = _.merge({}, styles, savedStyles)
    
    // CRITICAL: Ensure chart type is preserved after merge
    if (preservedChartType && mergedStyles.candle) {
      mergedStyles.candle.type = preservedChartType;
    }
    
    console.log('ðŸ”„ Merged styles (theme + saved):', JSON.stringify(mergedStyles, null, 2))
    const processedStyles = processLineChartStyles(mergedStyles)
    console.log('âœ¨ Final processed styles:', JSON.stringify(processedStyles, null, 2))
    $chart?.setStyles(processedStyles)
    console.log('âœ… Styles applied to chart via theme subscription')
    
    // CRITICAL FIX: Apply saved canvas colors after theme change
    // This ensures custom colors persist when switching between dark/light modes
    console.log('ðŸŽ¨ APPLYING SAVED CANVAS COLORS AFTER THEME CHANGE');
    setTimeout(() => {
      applyCanvasColors();
      console.log('âœ… Canvas colors reapplied after theme change');
    }, 100);
    
    // Debug: Check what the chart actually has after applying styles
    setTimeout(() => {
      console.log('ðŸ” CHART STATE CHECK after theme subscription:')
      const currentStyles = $chart?.getStyles()
      console.log('  - Current chart styles:', JSON.stringify(currentStyles, null, 2))
      console.log('  - Saved chart type in $save.styles:', $save.styles?.candle?.type)
    }, 200)
  })
  
  // ç›‘å¬æ—¶åŒºå˜åŒ–
  const timezone = derived(save, ($save) => $save.timezone);
  timezone.subscribe((new_val) => {
    $chart?.setTimezone(new_val)
    setTimezone(new_val)
  })
  
  // ç›‘å¬å›¾è¡¨ç±»åž‹å˜åŒ– (ç‰¹åˆ«æ˜¯Heikin Ashi) - with flicker-free rendering
  const chartType = derived(save, ($save) => $save.styles?.candle?.type);
  chartType.subscribe((new_val) => {
    if ($ctx.loadingKLine || customLoad) return
    
    // å½“åˆ‡æ¢åˆ°æˆ–ä»ŽHeikin Ashi/Renkoæ—¶ï¼Œé‡æ–°åŠ è½½æ•°æ®ä»¥åº”ç”¨è½¬æ¢
    const chartObj = $chart;
    if (!chartObj) return;
    // Reset renko earliest boundary on type change
    renkoEarliestRawTs = null;
    
    if (new_val === 'heikin_ashi' || new_val === 'renko_atr' || ((new_val !== 'heikin_ashi' && new_val !== 'renko_atr') && chartObj.getDataList().length > 0)) {
      // Use render integration for flicker-free chart type change
      renderIntegration.switchChartType({
        chart: chartObj,
        newType: new_val || 'candle_solid',
        reloadDataFn: async () => {
          await loadSymbolPeriod();
        }
      });
    }
  })

  // Reload when Renko settings change (ATR length, wick, source) while Renko is active
  const renkoConfig = derived(save, ($save) => {
    const cfg = ($save.styles as any)?.candle?.renko || {};
    // stringify to detect deep changes
    return JSON.stringify(cfg);
  });
  renkoConfig.subscribe((_str) => {
    if ($ctx.loadingKLine || customLoad) return;
    if (($save.styles?.candle?.type) !== 'renko_atr') return;
    const chartObj = $chart;
    if (!chartObj) return;
    renderIntegration.switchChartType({
      chart: chartObj,
      newType: 'renko_atr',
      reloadDataFn: async () => {
        await loadSymbolPeriod();
      }
    });
  });

  // ç›‘å¬æ•°æ®åŠ è½½åŠ¨ä½œ
  const fireOhlcv = derived(ctx, ($ctx) => $ctx.fireOhlcv);
  fireOhlcv.subscribe(async (val) => {
    if($ctx.timeStart && $ctx.timeEnd){
      await loadKlineRange($save.symbol, $save.period, $ctx.timeStart, $ctx.timeEnd)
      $ctx.timeStart = 0
      $ctx.timeEnd = 0
    }
    else{
      await customLoadKline()
    }
  })

  export function getChart(): Nullable<kc.Chart>{
    return $chart
  }
  
  export function setManualStylesFlag(value: boolean) {
    isApplyingManualStyles = value
  }

  function handleKeyDown(e: KeyboardEvent) {
    // Handle Delete key for removing selected overlay
    if (e.key === 'Delete' || e.key === 'Backspace') {
      e.preventDefault()
      drawBarRef?.clickRemove()
    }
  }

  // Mouse tracking for crosshair
  let mouseChartX = $state(0)
  let mouseChartY = $state(0)

  // Modal state
  let showModal = $state(false)
  let modalX = $state(0)
  let modalY = $state(0)
  let modalPrice = $state('')

  // Toast state
  let toastRef: Toast
  let showToast = $state(false)
  let toastMessage = $state('')

  // Double tap detection variables
  let lastTapTime = 0
  let tapCount = 0
  let tapTimeout: NodeJS.Timeout | null = null

  // What Next prediction state
  let isPredicting = $state(false)
  let predictedCandles: KLineData[] = $state([])
  let predictionCount = $state(0)
  let isAutoPlaying = $state(false)
  let autoPlayInterval: NodeJS.Timeout | null = null
  let playbackSpeed = $state(1) // 0.5x to 3x speed (1 = 2 seconds default)

  function handleMouseMove(e: MouseEvent) {
    // Track mouse position for crosshair price calculation
    const chartRect = chartRef?.getBoundingClientRect()
    if (chartRect) {
      mouseChartX = e.clientX - chartRect.left
      mouseChartY = e.clientY - chartRect.top
    }
  }

  function handleRightClick(e: MouseEvent) {
    e.preventDefault()
    
    // Disable context menu on mobile devices - use double tap instead
    if (isMobileDevice()) {
      return
    }
    
    const chartRect = chartRef?.getBoundingClientRect()
    if (chartRect) {
      const x = e.clientX - chartRect.left
      const y = e.clientY - chartRect.top
      showModalAtPosition(x, y)
    }
  }

  function handleTouchStart(e: TouchEvent) {
    if (e.touches.length === 1) {
      const touch = e.touches[0]
      
      // Update mouse position for touch
      const chartRect = chartRef?.getBoundingClientRect()
      if (chartRect) {
        mouseChartX = touch.clientX - chartRect.left
        mouseChartY = touch.clientY - chartRect.top
      }

      // Check if touch is on modal - if so, don't handle it here
      const target = e.target as HTMLElement
      if (showModal && target && (target.closest('.modal-content') || target.closest('.action-btn'))) {
        return
      }

      // Double tap detection for mobile modal
      const currentTime = Date.now()
      const timeDiff = currentTime - lastTapTime
      
      if (timeDiff < 300 && timeDiff > 0) {
        tapCount++
        if (tapCount === 2) {
          // Double tap detected - show modal
          e.preventDefault()
          if (chartRect) {
            const x = touch.clientX - chartRect.left
            const y = touch.clientY - chartRect.top
            showModalAtPosition(x, y)
          }
          tapCount = 0
          return
        }
      } else {
        tapCount = 1
        
        // Single tap - hide modal if it's open and not on modal content
        if (showModal) {
          e.preventDefault()
          hideModal()
          tapCount = 0
          return
        }
      }
      
      lastTapTime = currentTime
      
      // Clear tap count after delay
      if (tapTimeout) {
        clearTimeout(tapTimeout)
      }
      tapTimeout = setTimeout(() => {
        tapCount = 0
      }, 300)
    }
  }

  function handleClick(e: MouseEvent) {
    // Hide modal when clicking elsewhere
    if (showModal) {
      hideModal()
    }
  }

  function showModalAtPosition(x: number, y: number) {
    modalX = x
    modalY = y
    modalPrice = getCurrentPriceAtMouse()
    showModal = true
  }

  function hideModal() {
    showModal = false
  }

  function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
           ('ontouchstart' in window) || 
           (navigator.maxTouchPoints > 0)
  }

  async function copyToClipboard(text: string): Promise<boolean> {
    try {
      // Try modern clipboard API first
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text)
        console.log('âœ… Copied using modern clipboard API')
        return true
      }
    } catch (error) {
      console.warn('Modern clipboard API failed:', error)
    }

    // Fallback for mobile and older browsers
    try {
      // Create a temporary textarea element
      const textArea = document.createElement('textarea')
      textArea.value = text
      textArea.style.position = 'fixed'
      textArea.style.left = '-999999px'
      textArea.style.top = '-999999px'
      textArea.style.opacity = '0'
      textArea.style.pointerEvents = 'none'
      textArea.setAttribute('readonly', '')
      
      document.body.appendChild(textArea)
      
      // Select and copy the text
      textArea.focus()
      textArea.select()
      textArea.setSelectionRange(0, text.length)
      
      const successful = document.execCommand('copy')
      document.body.removeChild(textArea)
      
      if (successful) {
        console.log('âœ… Copied using fallback method')
        return true
      }
    } catch (error) {
      console.error('Fallback copy method failed:', error)
    }

    // Final fallback - try to use selection API
    try {
      const selection = window.getSelection()
      if (selection) {
        const range = document.createRange()
        const span = document.createElement('span')
        span.textContent = text
        span.style.position = 'fixed'
        span.style.left = '-999999px'
        span.style.opacity = '0'
        
        document.body.appendChild(span)
        range.selectNode(span)
        selection.removeAllRanges()
        selection.addRange(range)
        
        const successful = document.execCommand('copy')
        document.body.removeChild(span)
        selection.removeAllRanges()
        
        if (successful) {
          console.log('âœ… Copied using selection API fallback')
          return true
        }
      }
    } catch (error) {
      console.error('Selection API fallback failed:', error)
    }

    console.error('âŒ All copy methods failed')
    return false
  }

  /**
   * Create a single prediction
   */
  function createSinglePrediction() {
    const chartObj = $chart;
    if (!chartObj) {
      console.error('Chart not initialized');
      return false;
    }

    try {
      // Get current data
      const dataList = chartObj.getDataList();
      
      if (dataList.length < 10) {
        console.warn('âš ï¸ Need more historical data for prediction');
        return false;
      }

      // Check if market is likely closed
      const lastCandle = dataList[dataList.length - 1];
      const timeframeSeconds = tf_to_secs($save.period.timeframe);
      const timeframeMs = timeframeSeconds * 1000;
      
      const marketClosed = isMarketLikelyClosed(lastCandle.timestamp, timeframeMs);
      
      if (!marketClosed && predictionCount === 0) {
        const timeSinceLastCandle = Date.now() - lastCandle.timestamp;
        const minutesAgo = Math.floor(timeSinceLastCandle / 60000);
        console.info(`â„¹ï¸ Market appears to be open (last candle ${minutesAgo}m ago). Prediction is most useful when market is closed.`);
      }

      // Don't remove previous predictions - keep them all!
      // Use the full current data list (including any previous predictions)
      const baseData = dataList;

      // Predict next candle based on all available data
      const predictedCandle = predictNextCandle(baseData);

      if (!predictedCandle) {
        console.error('âŒ Failed to generate prediction');
        return false;
      }

      // Add the new predicted candle to our tracking array
      predictedCandles = [...predictedCandles, predictedCandle];
      predictionCount++;

      // Add prediction to chart - append to existing data
      const newDataList = [...baseData, predictedCandle];
      
      // Store current viewport
      const currentVisibleRange = chartObj.getVisibleRange();
      const shouldScrollToEnd = currentVisibleRange 
        ? (currentVisibleRange.to >= baseData.length - 2)
        : true;

      chartObj.applyNewData(newDataList, false);

      // Scroll to show the predicted candle
      if (shouldScrollToEnd) {
        setTimeout(() => {
          chartObj.scrollToRealTime();
        }, 50);
      }

      // Log success (no alert)
      const previousClose = baseData[baseData.length - 1].close;
      const priceChange = ((predictedCandle.close - previousClose) / previousClose) * 100;
      const direction = priceChange > 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';
      console.log(
        `${direction} Prediction #${predictionCount}: ${priceChange > 0 ? '+' : ''}${priceChange.toFixed(2)}% ` +
        `(Close: ${predictedCandle.close.toFixed(2)})`
      );

      console.log('âœ… Prediction added:', predictedCandle);
      console.log('ðŸ“Š Total predictions so far:', predictionCount);

      return true;
    } catch (error) {
      console.error('âŒ Prediction error:', error);
      return false;
    }
  }

  /**
   * Get interval based on speed (speed: 0.5 to 3)
   */
  function getIntervalFromSpeed(): number {
    // Base interval is 2000ms (2 seconds)
    // Speed 0.5 = 4000ms, Speed 1 = 2000ms, Speed 2 = 1000ms, Speed 3 = 667ms
    return Math.round(2000 / playbackSpeed);
  }

  /**
   * Restart auto-play with new speed
   */
  function restartAutoPlayWithSpeed() {
    if (!isAutoPlaying) return;
    
    // Clear existing interval
    if (autoPlayInterval) {
      clearInterval(autoPlayInterval);
      autoPlayInterval = null;
    }
    
    // Start new interval with updated speed
    const interval = getIntervalFromSpeed();
    autoPlayInterval = setInterval(() => {
      if (!isAutoPlaying) return;
      createSinglePrediction();
    }, interval);
    
    console.log(`âš¡ Speed changed: ${playbackSpeed}x (${interval}ms interval)`);
  }

  /**
   * Change playback speed
   */
  function changeSpeed(newSpeed: number) {
    playbackSpeed = newSpeed;
    restartAutoPlayWithSpeed();
  }

  /**
   * Start auto-playing predictions
   */
  function startAutoPlay() {
    if (isAutoPlaying) return;
    
    isAutoPlaying = true;
    console.log('â–¶ï¸ Auto-play started');
    
    // Create first candle immediately
    createSinglePrediction();
    
    // Then create new candles based on speed
    const interval = getIntervalFromSpeed();
    autoPlayInterval = setInterval(() => {
      if (!isAutoPlaying) return;
      createSinglePrediction();
    }, interval);
  }

  /**
   * Stop auto-playing predictions
   */
  function stopAutoPlay() {
    isAutoPlaying = false;
    if (autoPlayInterval) {
      clearInterval(autoPlayInterval);
      autoPlayInterval = null;
    }
    console.log('â¸ï¸ Auto-play stopped');
  }

  /**
   * Toggle auto-play (play/stop)
   */
  function handleWhatNext() {
    if (isAutoPlaying) {
      stopAutoPlay();
    } else {
      startAutoPlay();
    }
  }

  /**
   * Clear all predictions
   */
  function clearPredictions() {
    const chartObj = $chart;
    if (!chartObj || predictedCandles.length === 0) return;

    // Stop auto-play if running
    stopAutoPlay();

    try {
      const dataList = chartObj.getDataList();
      const predictedTimestamps = new Set(predictedCandles.map(c => c.timestamp));
      const dataWithoutPredictions = dataList.filter(c => !predictedTimestamps.has(c.timestamp));

      chartObj.applyNewData(dataWithoutPredictions, false);
      predictedCandles = [];
      predictionCount = 0;
      
      console.log('ðŸ§¹ Predictions cleared');
    } catch (error) {
      console.error('âŒ Error clearing predictions:', error);
    }
  }

  function resetChartView() {
    console.log('ðŸ”„ RESET CHART VIEW called')
    
    // Clear predictions on reset
    clearPredictions();
    
    const chartObj = $chart
    if (chartObj) {
      // CRITICAL: Preserve chart type and grid color settings before reset
      const currentStyles = $save.styles
      const preservedChartType = currentStyles?.candle?.type
      const preservedGridSettings = {
        gridType: currentStyles.gridType,
        gridOpacity: currentStyles.gridOpacity,
        gridGradient: currentStyles.gridGradient,
        gridHorizontalColor: currentStyles.grid?.horizontal?.color,
        gridVerticalColor: currentStyles.grid?.vertical?.color
      }
      
      console.log('ðŸ”’ Preserving chart type:', preservedChartType)
      console.log('ðŸŽ¨ Preserving grid settings:', preservedGridSettings)
      
      // Reset styles to theme defaults first
      const themeStyles = getThemeStyles($save.theme)
      console.log('ðŸŽ¨ Resetting to theme styles:', JSON.stringify(themeStyles, null, 2))
      
      // Apply theme styles but preserve critical settings
      const mergedStyles = { ...themeStyles } as any
      
      // CRITICAL: Preserve chart type
      if (preservedChartType) {
        if (!mergedStyles.candle) {
          mergedStyles.candle = {} as any
        }
        (mergedStyles.candle as any).type = preservedChartType
        console.log('âœ… Preserved chart type in reset:', preservedChartType)
      }
      
      if (preservedGridSettings.gridType === 'solid' && preservedGridSettings.gridHorizontalColor) {
        // Preserve solid grid color
        if (!(mergedStyles as any).grid) {
          (mergedStyles as any).grid = {}
        }
        if (!(mergedStyles as any).grid.horizontal) {
          (mergedStyles as any).grid.horizontal = {}
        }
        if (!(mergedStyles as any).grid.vertical) {
          (mergedStyles as any).grid.vertical = {}
        }
        (mergedStyles as any).grid.horizontal.color = preservedGridSettings.gridHorizontalColor
        (mergedStyles as any).grid.vertical.color = preservedGridSettings.gridVerticalColor || preservedGridSettings.gridHorizontalColor
      } else if (preservedGridSettings.gridType === 'gradient' && preservedGridSettings.gridGradient) {
        // Preserve gradient grid color
        const gradientCSS = (preservedGridSettings.gridGradient as any).css || generateGradientCSS(preservedGridSettings.gridGradient)
        if (gradientCSS) {
          if (!(mergedStyles as any).grid) {
            (mergedStyles as any).grid = {}
          }
          if (!(mergedStyles as any).grid.horizontal) {
            (mergedStyles as any).grid.horizontal = {}
          }
          if (!(mergedStyles as any).grid.vertical) {
            (mergedStyles as any).grid.vertical = {}
          }
          (mergedStyles as any).grid.horizontal.color = gradientCSS
          (mergedStyles as any).grid.vertical.color = gradientCSS
        }
      }
      
      chartObj.setStyles(processLineChartStyles(mergedStyles))
      
      // Reset all pane options to default (v9 compatibility)
      try {
        chartObj.setPaneOptions({})
      } catch (e) {
        // setPaneOptions API may differ in v9
      }
      
      // Note: Removed chartObj.removeOverlay() to preserve drawing lines
      
      // Reset zoom to default (1.0 scale)
      chartObj.zoomAtCoordinate(1.0, { x: 0, y: 0 })
      
      // Scroll to real time (latest data)
      chartObj.scrollToRealTime()
      
      // Reset save state but preserve chart type and grid settings
      save.update(s => {
        const newStyles: any = {}
        
        // CRITICAL: Preserve chart type
        if (preservedChartType) {
          if (!newStyles.candle) newStyles.candle = {}
          newStyles.candle.type = preservedChartType
        }
        
        // Preserve grid color settings
        if (preservedGridSettings.gridType) {
          newStyles.gridType = preservedGridSettings.gridType
        }
        if (preservedGridSettings.gridOpacity !== undefined) {
          newStyles.gridOpacity = preservedGridSettings.gridOpacity
        }
        if (preservedGridSettings.gridGradient) {
          newStyles.gridGradient = preservedGridSettings.gridGradient
        }
        if (preservedGridSettings.gridHorizontalColor) {
          if (!newStyles.grid) newStyles.grid = {}
          if (!newStyles.grid.horizontal) newStyles.grid.horizontal = {}
          if (!newStyles.grid.vertical) newStyles.grid.vertical = {}
          newStyles.grid.horizontal.color = preservedGridSettings.gridHorizontalColor
          newStyles.grid.vertical.color = preservedGridSettings.gridVerticalColor || preservedGridSettings.gridHorizontalColor
        }
        
        s.styles = newStyles
        s.options = {}
        return s
      })
      
      console.log('âœ… Grid settings preserved after reset')
      
      // Force a complete redraw
      chartObj.resize()
    }
  }

  function getCurrentPriceAtMouse() {
    const chartObj = $chart
    if (!chartObj || mouseChartX === null || mouseChartY === null) return ''
    
    try {
      // Get the chart container dimensions for accurate coordinate conversion
      const chartRect = chartRef?.getBoundingClientRect()
      if (!chartRect) {
        return ''
      }
      
      // First priority: Use the chart library's built-in coordinate conversion
      // This is the most accurate method as it uses the actual chart scale
      if (chartObj && typeof chartObj.convertFromPixel === 'function') {
        try {
          const result: any = chartObj.convertFromPixel([{ x: mouseChartX, y: mouseChartY }], { paneId: 'candle_pane' })
          if (result && Array.isArray(result) && result[0] && typeof result[0].value === 'number') {
            return result[0].value.toFixed(2)
          }
        } catch (e) {
          // Fall through to alternative methods
        }
      }
      
      // Second priority: Fallback to manual calculation
      
      // Third priority: Manual calculation based on visible data range
      // This is the most reliable fallback when other methods fail
      const visibleRange = chartObj.getVisibleRange()
      const dataList = chartObj.getDataList()
      
      if (!dataList || dataList.length === 0 || !visibleRange) {
        return ''
      }
      
      const visibleData = dataList.slice(visibleRange.from, visibleRange.to + 1)
      if (visibleData.length === 0) {
        return ''
      }
      
      // Find the actual min/max prices in the visible range
      let minPrice = Infinity
      let maxPrice = -Infinity
      
      visibleData.forEach(data => {
        minPrice = Math.min(minPrice, data.low)
        maxPrice = Math.max(maxPrice, data.high)
      })
      
      // Use the calculated min/max from visible data
      
      const priceRange = maxPrice - minPrice
      if (priceRange <= 0) {
        return ''
      }
      
      // Calculate price based on mouse Y position relative to chart height
      // Note: Chart Y coordinates are inverted (0 at top, height at bottom)
      const relativeY = mouseChartY / chartRect.height
      const price = maxPrice - (relativeY * priceRange)
      
      return price.toFixed(2)
      
    } catch (error) {
      return ''
    }
  }


  
  console.log('ðŸ“Š Chart script execution completed');
</script>



<div bind:this={mainContainerRef} class="kline-main" data-theme="{$save.theme}" 
     onclick={() => $ctx.clickChart += 1}>
  <div class="alerts-container">
    {#each $alerts as alert (alert.id)}
      <Alert type={alert.type} text={alert.text} />
    {/each}
  </div>
  <MenuBar customLoad={customLoad} bind:mainContainer={mainContainerRef} bind:sidebarHost={sidebarHostRef}/>
  <div class="chart-container">
    <div class="kline-content">
      {#if $save.showDrawBar}
        <DrawBar bind:this={drawBarRef}/>
      {/if}
      <div bind:this={chartRef} class="kline-widget" role="application" tabindex="0"
            onkeydown={handleKeyDown} 
            oncontextmenu={handleRightClick} 
            onmousemove={handleMouseMove}
            ontouchstart={handleTouchStart}
            onclick={handleClick}></div>
     </div>
     
     <!-- Right Sidebar -->
     <SidebarHost bind:this={sidebarHostRef} />
   </div>
   

   
   <!-- Loading indicator for infinite scrolling -->
   {#if isLoadingHistoricalData}
     <div class="historical-loading-indicator">
       <div class="loading-spinner"></div>
       <span>Loading historical data...</span>
     </div>
   {/if}

   <!-- Chart Modal -->
   <ChartModal 
     bind:isOpen={showModal}
     x={modalX}
     y={modalY}
     currentPrice={modalPrice}
     on:reset={resetChartView}
     on:copy={async (e) => {
       if (e.detail.price) {
         const success = await copyToClipboard(e.detail.price)
         if (success) {
           toastMessage = `Price ${e.detail.price} copied!`
           toastRef?.showToast()
           hideModal()
         } else {
           toastMessage = 'Failed to copy price'
           toastRef?.showToast()
         }
       }
     }}
     on:close={hideModal}
   />
   
   <!-- Toast Notification -->
  <Toast 
    bind:this={toastRef}
    bind:visible={showToast}
    message={toastMessage}
    duration={2000}
  />

  
  <!-- Unsaved Changes Warning Modal -->
  <UnsavedChangesModal 
    show={showUnsavedModal}
    title={'Unsaved changes'}
    message={'You made changes but did not save. Refresh will discard them.'}
    on:cancel={() => { showUnsavedModal = false; }}
    on:confirm={() => { 
      showUnsavedModal = false; 
      try { 
        if (drawingManager && hasUnsavedChanges()) {
          // Remove persisted working drawings so they don't survive reload
          drawingManager.clearPersistedStorage();
          // Also clear legacy/overlay stores that may rehydrate unsaved overlays
          try {
            const overlaysKey = ($save?.key || 'chart') + '_overlays';
            localStorage.removeItem(overlaysKey);
          } catch {}
          try {
            localStorage.removeItem('dataSpaceOverlays');
          } catch {}
        }
      } catch {}
      location.reload(); 
    }}
  />
  
  <!-- Save System Integration -->
  <SaveSystemIntegration />
</div>

<style>
  .kline-main{
    flex: 1;
    display: flex;
    flex-direction: column;
    position: relative;
    color: var(--text-color);
    background-color: var(--background-color);
    min-height: 0; /* Ensure proper flex behavior */
    height: 100%; /* Explicit height for proper layout */
    transition: none; /* Disable transitions during fullscreen changes */
  }
  
  /* Horizontal container for content and sidebar */
  .chart-container {
    flex: 1;
    display: flex;
    flex-direction: row;
    width: 100%;
    height: var(--widget-height);
    min-height: 0;
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1); /* Smooth resize transition */
  }
  
  .kline-main:fullscreen {
    width: 100vw !important;
    height: 100vh !important;
    --period-bar-height: 38px;
    --drawing-bar-width: 52px;
    --widget-width: calc(100% - var(--drawing-bar-width));
    --widget-height: calc(100% - var(--period-bar-height));
  }
  
  /* Ensure proper layout restoration after fullscreen */
  .kline-main:not(:fullscreen) {
    width: auto !important;
    height: 100% !important;
  }

  .kline-content{
    flex: 1;
    display: flex;
    flex-direction: row;
    min-width: 0; /* Allow flex item to shrink below content size */
    height: 100%;
    border-left: 3.5px solid var(--border-color);
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1); /* Smooth resize transition */
  }

  .kline-widget{
    flex: 1;
    width: var(--widget-width);
    height: 100%;
    margin-left: 0;
    padding: 0;
    overflow: hidden;
    outline: none;
    border-right: 3.5px solid var(--border-color);
    background-color: var(--chart-background-color, var(--background-color));
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1); /* Smooth resize transition */
  }

  .kline-widget:focus {
    outline: none;
  }

  :host {
    --period-bar-height: 38px;
    --drawing-bar-width: 52px;
    --widget-width: calc(100% - var(--drawing-bar-width));
    --widget-height: calc(100% - var(--period-bar-height));
  }

  [data-theme="light"] {
    --primary-color: #1677ff;
    --selected-color: fade(#1677ff, 15%);
    --hover-background-color: rgba(22, 119, 255, 0.15);
    --background-color: #ffffff;
    --popover-background-color: #ffffff;
    --text-color: #051441;
    --text-second-color: #76808F;
    --border-color: #ebedf1;
    --chart-background-color: #ffffff;
    --separator-hover-color: rgba(221, 221, 221, 0.5);
    --separator-active-color: rgba(221, 221, 221, 0.7);
  }
  [data-theme="dark"] {
    --primary-color: #1677ff;
    --selected-color: fade(#1677ff, 15%);
    --hover-background-color: rgba(22, 119, 255, 0.15);
    --background-color: #0f0f0f;
    --popover-background-color: #1c1c1f;
    --text-color: #cccccc;
    --text-second-color: #929AA5;
    --border-color: #292929;
    --chart-background-color: #0f0f0f;
    --separator-hover-color: rgba(85, 85, 85, 0.5);
    --separator-active-color: rgba(85, 85, 85, 0.7);
  }


  @font-face {
    font-family: 'icomoon';
    src:  url('/fonts/icomoon.eot?f4efml');
    src:  url('/fonts/icomoon.eot?f4efml#iefix') format('embedded-opentype'),
      url('/fonts/icomoon.ttf?f4efml') format('truetype'),
      url('/fonts/icomoon.woff?f4efml') format('woff'),
      url('/fonts/icomoon.svg?f4efml#icomoon') format('svg');
    font-weight: normal;
    font-style: normal;
    font-display: block;
  }







  /* Historical data loading indicator */
  .historical-loading-indicator {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: var(--popover-background-color);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: var(--text-second-color);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
  }

  .loading-spinner {
    width: 14px;
    height: 14px;
    border: 2px solid var(--border-color);
    border-top: 2px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Mobile responsive styles */
  @media (max-width: 768px) {
    .kline-main {
      min-height: 400px; /* Ensure minimum height on mobile */
    }
    
    .chart-container {
      height: calc(100vh - var(--period-bar-height) - 60px); /* Account for mobile browser UI */
      min-height: 350px;
    }
    
    .kline-widget {
      padding-bottom: 20px; /* Extra padding to prevent XAxis text cutoff */
      box-sizing: border-box;
    }
    
    .kline-content {
      border-left-width: 2px; /* Thinner border on mobile */
    }
    
    .kline-widget {
      border-right-width: 2px; /* Thinner border on mobile */
    }


  }

  @media (max-width: 480px) {
    .kline-main {
      min-height: 350px; /* Smaller minimum height for very small screens */
    }
    
    .chart-container {
      height: calc(100vh - var(--period-bar-height) - 80px); /* More space for mobile browser UI */
      min-height: 300px;
    }
    
    .kline-widget {
      padding-bottom: 25px; /* More padding for very small screens */
    }
    
    .kline-content {
      border-left-width: 1px; /* Even thinner border on small mobile */
    }
    
    .kline-widget {
      border-right-width: 1px; /* Even thinner border on small mobile */
    }
  }

  /* Enhanced separator styling for better interaction */
  :global(.klinecharts-pane-separator) {
    position: relative !important;
    cursor: ns-resize !important;
    transition: background-color 0.2s ease !important;
    z-index: 10 !important;
    /* Performance optimizations */
    will-change: transform, background-color !important;
    transform: translateZ(0) !important; /* Force hardware acceleration */
    backface-visibility: hidden !important;
    perspective: 1000px !important;
    contain: layout style paint !important; /* CSS containment for better performance */
  }

  /* Enhanced touch area for mobile */
  :global(.klinecharts-pane-separator::before) {
    content: '' !important;
    position: absolute !important;
    top: -5px !important;
    left: 0 !important;
    right: 0 !important;
    bottom: -5px !important;
    background: transparent !important;
    cursor: ns-resize !important;
    z-index: 11 !important;
  }

  /* Hover effects for desktop */
  :global(.klinecharts-pane-separator:hover) {
    background-color: var(--separator-hover-color) !important;
  }

  /* Active state during drag */
  :global(.klinecharts-pane-separator:active),
  :global(.klinecharts-pane-separator.dragging) {
    background-color: var(--separator-active-color) !important;
  }

  /* Touch-friendly sizing for mobile devices */
  @media (pointer: coarse) {
    :global(.klinecharts-pane-separator::before) {
      top: -8px !important;
      bottom: -8px !important;
    }
    
    :global(.klinecharts-pane-separator) {
      min-height: 16px !important;
    }
  }

  /* High DPI support */
  @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    :global(.klinecharts-pane-separator) {
      transform: translateZ(0) !important;
    }
  }

</style>
<script lang="ts">
import type {OverlayEvent} from 'klinecharts';
import {OverlayMode, LineType} from 'klinecharts';
import { getContext, onMount, onDestroy } from 'svelte';
import type { Chart } from 'klinecharts'
import {ChartSave} from './chart';
import type {Writable} from 'svelte/store';
import {persisted} from 'svelte-persisted-store';
import KlineIcon from './icon.svelte';
import type {Nullable} from 'klinecharts';
import * as m from '$lib/paraglide/messages.js'
import {derived} from 'svelte/store';
import type {ChartCtx} from './chart';
import _ from 'lodash';
import { overlayMap } from './overlays'
import ColorPicker from '../ColorPicker.svelte';

let popoverKey = $state('');
let modeIcon = $state('weakMagnet')
let mode = $state('normal')
let lock = $state(false)
let visiable = $state(true)
let hisLays: string[] = $state([])  // 按创建顺序，记录所有overlay，方便删除
let selectDraw = $state('')
let selectedOverlayCoords = $state<{x: number, y: number} | null>(null)
let showDeleteButton = $state(false)
let showContextMenu = $state(false)
let selectedOverlay = $state<any>(null)
let contextMenuStyles = $state({
  thickness: 2,
  style: 'solid',
  color: '#1677FF'
})

// Drag functionality for context menu
let isDragging = $state(false)
let dragOffset = $state({ x: 0, y: 0 })
let contextMenuPosition = $state<{x: number, y: number} | null>(null)
let savedContextMenuPosition = $state<{x: number, y: number} | null>(null)

// Color picker state
let showColorPicker = $state(false)
let colorPickerPosition = $state({ x: 0, y: 0 })

// Chart container reference for relative positioning
let chartContainer: HTMLElement | null = null

// Function to get chart container bounds
function getChartContainerBounds() {
  if (!chartContainer) {
    // Try to find chart container
    chartContainer = document.querySelector('.chart-container') || document.querySelector('[data-chart-container]') || document.body
  }
  return chartContainer?.getBoundingClientRect() || { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight }
}

// Function to update context menu position relative to chart
function updateContextMenuPosition() {
  if (!showContextMenu || !selectedOverlay || !contextMenuPosition) return
  
  // Get current overlay position
  if (selectedOverlay.points && selectedOverlay.points.length > 0) {
    const firstPoint = selectedOverlay.points[0]
    const coords = $chart?.convertToPixel(firstPoint, { paneId: 'candle_pane' })
    
    if (coords && typeof coords === 'object' && 'x' in coords && 'y' in coords && coords.x !== undefined && coords.y !== undefined) {
      const chartBounds = getChartContainerBounds()
      
      // Calculate position relative to chart container
      const relativeX = coords.x - 80
      const relativeY = coords.y - 30
      
      // Ensure menu stays within viewport bounds
      const menuWidth = 300
      const menuHeight = 200
      
      const finalX = Math.max(10, Math.min(relativeX, chartBounds.width - menuWidth))
      const finalY = Math.max(10, Math.min(relativeY, chartBounds.height - menuHeight))
      
      contextMenuPosition = { x: finalX, y: finalY }
    }
  }
}

// Function to update color picker position
function updateColorPickerPosition() {
  if (!showColorPicker) return
  
  const chartBounds = getChartContainerBounds()
  const pickerWidth = 320
  const pickerHeight = 400
  
  // Keep color picker within bounds
  colorPickerPosition = {
    x: Math.max(10, Math.min(colorPickerPosition.x, chartBounds.width - pickerWidth)),
    y: Math.max(10, Math.min(colorPickerPosition.y, chartBounds.height - pickerHeight))
  }
}

// Window resize handler
function handleWindowResize() {
  updateContextMenuPosition()
  updateColorPickerPosition()
}

// Load saved context menu position from localStorage
function loadSavedPosition() {
  if (typeof localStorage !== 'undefined') {
    const saved = localStorage.getItem('contextMenuPosition')
    if (saved) {
      try {
        savedContextMenuPosition = JSON.parse(saved)
      } catch (e) {
        console.log('Error loading saved position:', e)
      }
    }
  }
}

// Save context menu position to localStorage
function savePosition(position: {x: number, y: number}) {
  if (typeof localStorage !== 'undefined') {
    localStorage.setItem('contextMenuPosition', JSON.stringify(position))
    savedContextMenuPosition = position
  }
}

const lineStyles = [
  { key: 'solid', name: 'Solid', pattern: '────────' },
  { key: 'dashed', name: 'Dashed', pattern: '── ── ──' },
  { key: 'dotted', name: 'Dotted', pattern: '· · · · · ·' }
]

const colorPresets = [
  '#1677FF', '#FF4D4F', '#52C41A', '#FAAD14', 
  '#722ED1', '#13C2C2', '#FA541C', '#F759AB',
  '#2F54EB', '#389E0D', '#D4380D', '#7CB305'
]

const GROUP_ID = 'drawing_tools'

const save = getContext('save') as Writable<ChartSave>
const ctx = getContext('ctx') as Writable<ChartCtx>
const chart = getContext('chart') as Writable<Nullable<Chart>>
const overlays = persisted<Record<string, Record<string, any>>>($save.key + '_overlays', {})

function getOverlayKey(overlayId: string): string {
  const sym = $save.symbol;
  const symbol = sym.shortName ?? sym.name ?? sym.ticker;
  return `${symbol}_${$save.period.timeframe}_${overlayId}`
}

const singleLineOpts = [
  { key: 'segment', text: 'segment' },
  { key: 'arrow', text: 'arrow' },
  { key: 'rayLine', text: 'ray_line' },
  { key: 'straightLine', text: 'straight_line' },
  { key: 'priceLine', text: 'price_line' },
  { key: 'horizontalStraightLine', text: 'horizontal_straight_line' },
  { key: 'horizontalRayLine', text: 'horizontal_ray_line' },
  { key: 'horizontalSegment', text: 'horizontal_segment' },
  { key: 'verticalStraightLine', text: 'vertical_straight_line' },
  { key: 'verticalRayLine', text: 'vertical_ray_line' },
  { key: 'verticalSegment', text: 'vertical_segment' },
]

const moreLineOpts = [
  { key: 'priceChannelLine', text: 'price_channel_line' },
  { key: 'parallelStraightLine', text: 'parallel_straight_line' }
]

const polygonOpts = [
  { key: 'circle', text: 'circle' },
  { key: 'rect', text: 'rect' },
  { key: 'parallelogram', text: 'parallelogram' },
  { key: 'triangle', text: 'triangle' }
]

const fibonacciOpts = [
  { key: 'fibonacciSegment', text: 'fibonacci_segment' },
  { key: 'fibonacciLine', text: 'fibonacci_line' },
  { key: 'fibonacciCircle', text: 'fibonacci_circle' },
  { key: 'fibonacciSpiral', text: 'fibonacci_spiral' },
  { key: 'fibonacciSpeedResistanceFan', text: 'fibonacci_speed_resistance_fan' },
  { key: 'fibonacciExtension', text: 'fibonacci_extension' },
  { key: 'gannBox', text: 'gann_box' }
]

const waveOpts = [
  { key: 'xabcd', text: 'xabcd' },
  { key: 'abcd', text: 'abcd' },
  { key: 'threeWaves', text: 'three_waves' },
  { key: 'fiveWaves', text: 'five_waves' },
  { key: 'eightWaves', text: 'eight_waves' },
  { key: 'anyWaves', text: 'any_waves' },
]

const subMenu = $state([
  { key: 'single-line', icon: 'segment', list: singleLineOpts },
  { key: 'more-line', icon: 'priceChannelLine', list: moreLineOpts },
  { key: 'polygon', icon: 'circle', list: polygonOpts },
  { key: 'fibonacci', icon: 'fibonacciSegment', list: fibonacciOpts },
  { key: 'wave', icon: 'xabcd', list: waveOpts }
])

const modes = $state([
  { key: 'weakMagnet', text: 'weakMagnet' },
  { key: 'strongMagnet', text: 'strongMagnet' }
])

function clickPopoverKey(val: string){
  if (popoverKey == val){
    popoverKey = ""
  }else{
    popoverKey = val
  }
}

export function addOverlay(data: any){
  let moved = false;
  const overlayClass = overlayMap[data.name] ?? {}
  const defData = {
    groupId: GROUP_ID,
    onDrawEnd: (event: OverlayEvent) => {
      if(overlayClass.onDrawEnd){
        overlayClass.onDrawEnd(event)
      }
      // Save the overlay data
      editOverlay(event.overlay)
      return true
    },
    onPressedMoving: (event: OverlayEvent) => {
      if(overlayClass.onPressedMoving){
        overlayClass.onPressedMoving(event)
      }
      moved = true;
      return false
    },
    onPressedMoveEnd: (event: OverlayEvent) => {
      if(overlayClass.onPressedMoveEnd){
        overlayClass.onPressedMoveEnd(event)
      }
      if(!moved)return true
      moved = false
      editOverlay(event.overlay)
      
      // Update delete button position if this overlay is selected
      if (selectDraw === event.overlay.id && event.overlay.points && event.overlay.points.length > 0) {
        const firstPoint = event.overlay.points[0]
        const coords = $chart?.convertToPixel(firstPoint, { paneId: 'candle_pane' })
        if (coords && typeof coords === 'object' && 'x' in coords && 'y' in coords && coords.x !== undefined && coords.y !== undefined) {
          selectedOverlayCoords = { x: coords.x - 80, y: coords.y - 30 }
        }
      }
      return true
    },
    onSelected: (event: OverlayEvent) => {
      if(overlayClass.onSelected){
        overlayClass.onSelected(event)
      }
      selectDraw = event.overlay.id
      selectedOverlay = event.overlay
      
      // Set current styles from selected overlay
      if (event.overlay.styles?.line) {
        const lineStyles = event.overlay.styles.line
        contextMenuStyles.thickness = lineStyles.size || 2
        contextMenuStyles.color = lineStyles.color || '#1677FF'
        contextMenuStyles.style = lineStyles.style === LineType.Dashed ? 'dashed' : 'solid'
      }
      
      // Show context menu near the selected overlay
      if (event.overlay.points && event.overlay.points.length > 0) {
        const firstPoint = event.overlay.points[0]
        const coords = $chart?.convertToPixel(firstPoint, { paneId: 'candle_pane' })
        if (coords && typeof coords === 'object' && 'x' in coords && 'y' in coords && coords.x !== undefined && coords.y !== undefined) {
          selectedOverlayCoords = { x: coords.x - 80, y: coords.y - 30 }
          
          // Use saved position if available, otherwise use default position
          if (savedContextMenuPosition) {
            contextMenuPosition = { ...savedContextMenuPosition }
          } else {
            contextMenuPosition = { x: coords.x - 80, y: coords.y - 30 }
          }
          
          showContextMenu = true
          showDeleteButton = false
          // Load current overlay styles
            if (event.overlay.styles && event.overlay.styles.line) {
              contextMenuStyles.thickness = event.overlay.styles.line.size || 1
              contextMenuStyles.color = event.overlay.styles.line.color || '#1677FF'
              
              // Determine style based on LineType and dashedValue
              if (event.overlay.styles.line.style === LineType.Dashed) {
                const dashedValue = event.overlay.styles.line.dashedValue
                if (dashedValue && dashedValue[0] === 2 && dashedValue[1] === 8) {
                  contextMenuStyles.style = 'dotted'
                } else {
                  contextMenuStyles.style = 'dashed'
                }
              } else {
                contextMenuStyles.style = 'solid'
              }
            }
        }
      }
      return true;
    },
    onDeselected: (event: OverlayEvent) => {
      if(overlayClass.onDeselected){
        overlayClass.onDeselected(event)
      }
      selectDraw = ''
      showDeleteButton = false
      showContextMenu = false
      selectedOverlayCoords = null
      selectedOverlay = null
      return true;
    },
    onRemoved: (event: OverlayEvent) => {
      if(overlayClass.onRemoved){
        overlayClass.onRemoved(event)
      }
      overlays.update(ol => {
        delete ol[getOverlayKey(event.overlay.id)]
        return ol
      })
      return true
    }
  }
  // 合并时保留原有的事件处理器
  const layId = $chart?.createOverlay(_.mergeWith({}, defData, data, (objValue, srcValue, key) => {
    if (key.startsWith('on') && objValue && srcValue) {
      return (event: OverlayEvent) => {
        srcValue(event)
        return objValue(event)
      }
    }
  }))
  if(layId){
    if(Array.isArray(layId)){
      hisLays.push(...(layId as string[]))
    }
    else{
      hisLays.push(layId as string)
    }
  }
  return layId;
}

function startOverlay(val: string){
  addOverlay({
    name: val,
    visible: visiable,
    lock: lock,
    mode: mode as OverlayMode,
  })
}


function clickSubPopover(index: number, value: string){
  subMenu[index].icon = value;
  startOverlay(value)
  popoverKey = '';
}

function clickMode(){
  let cur_mode = modeIcon
  if (mode !== 'normal') {
    cur_mode = 'normal'
  }
  mode = cur_mode;
  $chart?.overrideOverlay({ mode: cur_mode as OverlayMode })
}

function clickSubMode(value: string){
  modeIcon = value;
  mode = value;
  popoverKey = '';
  $chart?.overrideOverlay({ mode: value as OverlayMode })
}

function toggleLock(){
  lock = !lock;
  $chart?.overrideOverlay({ lock: lock });
}

function toggleVisiable(){
  visiable = !visiable
  $chart?.overrideOverlay({ visible: visiable })
}

export function clickRemove(){
  let args: any = { groupId: GROUP_ID };
  if(selectDraw){
    args['id'] = selectDraw
  }
  else if(hisLays.length > 0){
    args['id'] = hisLays.pop()
  }
  $chart?.removeOverlay(args)
  showContextMenu = false
  showDeleteButton = false
  selectedOverlayCoords = null
  selectedOverlay = null
}

function updateOverlayStyles() {
  if (!selectedOverlay || !$chart) return
  
  let lineStyle = LineType.Solid
  let dashedValue = [8, 4] // Default dashed pattern
  
  if (contextMenuStyles.style === 'dashed') {
    lineStyle = LineType.Dashed
    dashedValue = [8, 4]
  } else if (contextMenuStyles.style === 'dotted') {
    lineStyle = LineType.Dashed // KLineCharts doesn't have dotted, use dashed with small pattern
    dashedValue = [2, 6]
  }
  
  const newStyles = {
    line: {
      size: contextMenuStyles.thickness,
      color: contextMenuStyles.color,
      style: lineStyle,
      dashedValue: dashedValue
    },
    // Also update text color if overlay has text
    text: {
      color: contextMenuStyles.color
    },
    // Update polygon fill color with transparency
    polygon: {
      color: contextMenuStyles.color + '20' // Add 20% opacity
    }
  }
  
  try {
    $chart.overrideOverlay({
      id: selectedOverlay.id,
      styles: newStyles
    })
  } catch (e) {
    // Handle API compatibility issues
    console.log('Error updating overlay styles:', e)
  }
  
  // Update stored overlay data
  editOverlay({
    ...selectedOverlay,
    styles: { ...selectedOverlay.styles, ...newStyles }
  })
}

// Drag functionality for context menu
function startDrag(e: MouseEvent) {
  isDragging = true
  const rect = (e.target as HTMLElement).closest('.context-menu-container')?.getBoundingClientRect()
  if (rect && contextMenuPosition) {
    dragOffset.x = e.clientX - contextMenuPosition.x
    dragOffset.y = e.clientY - contextMenuPosition.y
  }
  e.preventDefault()
}

function onMouseMove(e: MouseEvent) {
  if (isDragging && contextMenuPosition) {
    contextMenuPosition.x = Math.max(10, Math.min(e.clientX - dragOffset.x, window.innerWidth - 300))
    contextMenuPosition.y = Math.max(10, Math.min(e.clientY - dragOffset.y, window.innerHeight - 60))
  }
}

function stopDrag() {
  if (isDragging && contextMenuPosition) {
    savePosition(contextMenuPosition)
  }
  isDragging = false
}

// Color picker functions
function openColorPicker(event: MouseEvent) {
  event.stopPropagation()
  const rect = (event.target as HTMLElement).getBoundingClientRect()
  colorPickerPosition = {
    x: Math.max(10, Math.min(rect.left, window.innerWidth - 320)), // 320px is color picker width
    y: Math.max(10, Math.min(rect.bottom + 5, window.innerHeight - 400)) // 400px estimated height
  }
  showColorPicker = true
}

function handleColorChange(event: CustomEvent) {
  contextMenuStyles.color = event.detail
  updateOverlayStyles()
}

function handleOpacityChange(event: CustomEvent) {
  // Handle opacity change if needed
  console.log('Opacity changed:', event.detail)
}

function closeColorPicker() {
  showColorPicker = false
}

function editOverlay(overlay: any){
  if(overlay.groupId !== GROUP_ID)return
  const keys = ['extendData', 'groupId', 'id', 'lock', 'mode', 'name', 'paneId', 'points', 'styles',
    'totalStep', 'visible', 'zLevel']
  const oid = getOverlayKey(overlay['id'])
  overlays.update(ol => {
    ol[oid] = Object.fromEntries(keys.map(k => [k, overlay[k]]))
    return ol
  })
}

const clickChart = derived(ctx, ($ctx) => $ctx.clickChart);
clickChart.subscribe(() => {
  popoverKey = ''
})

const cloudIndLoaded = derived(ctx, ($ctx) => $ctx.cloudIndLoaded);
cloudIndLoaded.subscribe(() => {
  const currentPrefix = getOverlayKey('')
  Object.entries($overlays).forEach(([key, v]) => {
    if (key.startsWith(currentPrefix)) {
      addOverlay(v)
    }
  })
})

// Global mouse event listeners for drag functionality
onMount(() => {
  loadSavedPosition()
  if (typeof document !== 'undefined') {
    document.addEventListener('mousemove', onMouseMove)
    document.addEventListener('mouseup', stopDrag)
  }
  if (typeof window !== 'undefined') {
    window.addEventListener('resize', handleWindowResize)
  }
})

onDestroy(() => {
  if (typeof document !== 'undefined') {
    document.removeEventListener('mousemove', onMouseMove)
    document.removeEventListener('mouseup', stopDrag)
  }
  if (typeof window !== 'undefined') {
    window.removeEventListener('resize', handleWindowResize)
  }
})
</script>

{#snippet DrawButton(onClick: () => void, icon: string, itemKey: string = '', subItems: {key: string, text: string}[] = [])}
  <div class="group flex flex-row items-center justify-center relative w-full mt-2 cursor-pointer text-base-content/70">
    <span class="w-8 h-8 hover:text-primary" onclick={onClick}>
      <KlineIcon name={icon} active={itemKey === 'mode' && mode === modeIcon}/>
    </span>
    {#if subItems.length > 0}
      <div 
        class="flex flex-row items-center justify-center absolute top-0 right-0 h-8 w-[10px] opacity-0 group-hover:opacity-100 hover:opacity-100 transition-all duration-200 rounded-l hover:bg-base-200 z-10"
        onclick={() => clickPopoverKey(itemKey)}
      >
        <svg class:rotate-180={popoverKey === icon} class="w-1 h-1.5 transition-all duration-200 arrow-icon" viewBox="0 0 4 6">
          <path d="M1.07298,0.159458C0.827521,-0.0531526,0.429553,-0.0531526,0.184094,0.159458C-0.0613648,0.372068,-0.0613648,0.716778,0.184094,0.929388L2.61275,3.03303L0.260362,5.07061C0.0149035,5.28322,0.0149035,5.62793,0.260362,5.84054C0.505822,6.05315,0.903789,6.05315,1.14925,5.84054L3.81591,3.53075C4.01812,3.3556,4.05374,3.0908,3.92279,2.88406C3.93219,2.73496,3.87113,2.58315,3.73964,2.46925L1.07298,0.159458Z" stroke="none" stroke-opacity="0"/>
        </svg>
      </div>
      {#if itemKey === popoverKey}
        <ul class="absolute top-0 left-[calc(100%+1px)] whitespace-nowrap z-50 shadow-xl min-h-0" style="background-color: var(--popover-background-color); border: 1px solid var(--border-color);">
          {#each subItems as data}
            <li class="px-4 flex flex-row items-center h-10" 
              style="color: var(--text-color); background-color: transparent;"
              onmouseenter={(e) => (e.target as HTMLElement).style.backgroundColor = 'var(--selected-color)'}
              onmouseleave={(e) => (e.target as HTMLElement).style.backgroundColor = 'transparent'}
              onclick={() => itemKey === 'mode' ? clickSubMode(data.key) : clickSubPopover(subMenu.findIndex(i => i.key === itemKey), data.key)}>
              <KlineIcon name={data.key}/>
              <span class="pl-2">{m[data.text as keyof typeof m]()}</span>
            </li>
          {/each}
        </ul>
      {/if}
    {/if}
  </div>
{/snippet}

{#snippet Divider()}
  <div class="w-full h-px bg-base-content/20 mt-2"></div>
{/snippet}

<div class="w-[48px] h-full box-border border-r border-base-content/20" onclick={(e) => e.stopPropagation()}>
  {#each subMenu as item}
    {@render DrawButton(() => startOverlay(item.icon), item.icon, item.key, item.list)}
  {/each}
  
  {@render Divider()}
  
  {@render DrawButton(() => startOverlay('ruler'), 'ruler')}
  
  {@render Divider()}
  
  {@render DrawButton(clickMode, modeIcon, 'mode', modes)}
  
  {@render Divider()}
  
  {@render DrawButton(toggleLock, lock ? 'lock' : 'unlock')}
  
  {@render Divider()}
  
  {@render DrawButton(toggleVisiable, visiable ? 'visible' : 'invisible')}
  
  {@render Divider()}
  
  {@render DrawButton(clickRemove, 'remove')}
</div>

<!-- Minimalist Context menu for selected drawing -->
{#if showContextMenu && contextMenuPosition}
  <div 
    class="context-menu-container fixed z-50 rounded-lg shadow-lg px-3 py-2
           dark:bg-[#2A2A2A] dark:border-[#404040] 
           bg-white border border-gray-200 {isDragging ? 'cursor-grabbing' : ''}"
    style="left: {contextMenuPosition.x}px; 
           top: {contextMenuPosition.y}px;"
    onclick={(e) => e.stopPropagation()}
  >
    
    <!-- Minimalist horizontal toolbar -->
    <div class="flex items-center gap-4">
      <!-- Drag handle with 6 dots design -->
      <div 
        class="drag-handle cursor-grab hover:cursor-grabbing flex items-center justify-center w-6 h-6 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
        onmousedown={startDrag}
        title="Drag to move"
      >
        <div class="flex flex-col gap-0.5">
          <div class="flex gap-0.5">
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
          </div>
          <div class="flex gap-0.5">
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
          </div>
          <div class="flex gap-0.5">
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
          </div>
        </div>
      </div>
      <!-- Color picker button -->
      <button 
        class="w-8 h-8 rounded border-2 border-gray-300 dark:border-gray-600 cursor-pointer hover:scale-110 transition-transform"
        style="background-color: {contextMenuStyles.color};"
        onclick={openColorPicker}
        title="Choose color"
      ></button>
      
      <!-- Thickness with visual indicator -->
      <div class="flex items-center gap-2">
        <input 
          type="range" 
          min="1" 
          max="8" 
          bind:value={contextMenuStyles.thickness}
          oninput={updateOverlayStyles}
          class="w-20 h-1 dark:bg-gray-600 bg-gray-300 rounded appearance-none cursor-pointer"
        />
        <span class="text-xs dark:text-gray-300 text-gray-600 min-w-[24px]">{contextMenuStyles.thickness}px</span>
      </div>
      
      <!-- Line style dropdown -->
      <select 
        bind:value={contextMenuStyles.style}
        onchange={updateOverlayStyles}
        class="px-2 py-1 text-sm border rounded cursor-pointer
               dark:bg-[#2C2C2C] dark:border-[#3A3A3A] dark:text-white
               bg-white border-gray-300 text-gray-900"
      >
        <option value="solid">Line</option>
        <option value="dashed">Dashed</option>
        <option value="dotted">Dotted</option>
      </select>
      
      <!-- Delete button -->
      <button 
        class="w-8 h-8 rounded hover:bg-red-100 dark:hover:bg-red-900 transition-colors duration-200
               flex items-center justify-center"
        onclick={() => { clickRemove(); showContextMenu = false; selectedOverlayCoords = null; }}
        title="Delete"
      >
        <svg class="w-4 h-4 text-gray-600 dark:text-gray-300 hover:text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
        </svg>
      </button>
    </div>
  </div>
{/if}

<!-- Delete button overlay for selected drawing -->
{#if showDeleteButton && selectedOverlayCoords}
  <div 
    class="fixed z-50 bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center cursor-pointer shadow-lg transition-all duration-200"
    style="left: {selectedOverlayCoords.x}px; top: {selectedOverlayCoords.y}px;"
    onclick={clickRemove}
    title="Delete selected drawing"
  >
    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
    </svg>
  </div>
{/if}

<!-- Advanced Color Picker -->
<ColorPicker 
  bind:selectedColor={contextMenuStyles.color}
  bind:show={showColorPicker}
  bind:position={colorPickerPosition}
  on:colorChange={handleColorChange}
  on:opacityChange={handleOpacityChange}
  on:close={closeColorPicker}
/>

<style>
  .arrow-icon path {
    fill: #333333;
  }
  
  :global([data-theme="dark"]) .arrow-icon path {
    fill: white;
  }
  
  :global([data-theme="light"]) .arrow-icon path {
    fill: #333333;
  }
</style>



// Color picker state
let showColorPicker = $state(false)
let colorPickerPosition = $state({ x: 0, y: 0 })

// Chart container reference for relative positioning
let chartContainer: HTMLElement | null = null

// Function to get chart container bounds
function getChartContainerBounds() {
  if (!chartContainer) {
    // Try to find chart container
    chartContainer = document.querySelector('.chart-container') || document.querySelector('[data-chart-container]') || document.body
  }
  return chartContainer?.getBoundingClientRect() || { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight }
}

// Function to update context menu position relative to chart
function updateContextMenuPosition() {
  if (!showContextMenu || !selectedOverlay || !contextMenuPosition) return
  
  // Get current overlay position
  if (selectedOverlay.points && selectedOverlay.points.length > 0) {
    const firstPoint = selectedOverlay.points[0]
    const coords = $chart?.convertToPixel(firstPoint, { paneId: 'candle_pane' })
    
    if (coords && typeof coords === 'object' && 'x' in coords && 'y' in coords && coords.x !== undefined && coords.y !== undefined) {
      const chartBounds = getChartContainerBounds()
      
      // Calculate position relative to chart container
      const relativeX = coords.x - 80
      const relativeY = coords.y - 30
      
      // Ensure menu stays within viewport bounds
      const menuWidth = 300
      const menuHeight = 200
      
      const finalX = Math.max(10, Math.min(relativeX, chartBounds.width - menuWidth))
      const finalY = Math.max(10, Math.min(relativeY, chartBounds.height - menuHeight))
      
      contextMenuPosition = { x: finalX, y: finalY }
    }
  }
}

// Function to update color picker position
function updateColorPickerPosition() {
  if (!showColorPicker) return
  
  const chartBounds = getChartContainerBounds()
  const pickerWidth = 320
  const pickerHeight = 400
  
  // Keep color picker within bounds
  colorPickerPosition = {
    x: Math.max(10, Math.min(colorPickerPosition.x, chartBounds.width - pickerWidth)),
    y: Math.max(10, Math.min(colorPickerPosition.y, chartBounds.height - pickerHeight))
  }
}

// Window resize handler
function handleWindowResize() {
  updateContextMenuPosition()
  updateColorPickerPosition()
}

function handleColorChange(event: CustomEvent) {
  contextMenuStyles.color = event.detail
  updateOverlayStyles()
}

function handleOpacityChange(event: CustomEvent) {
  // Handle opacity change if needed
  console.log('Opacity changed:', event.detail)
}

function closeColorPicker() {
  showColorPicker = false
}

function editOverlay(overlay: any){
  if(overlay.groupId !== GROUP_ID)return
  const keys = ['extendData', 'groupId', 'id', 'lock', 'mode', 'name', 'paneId', 'points', 'styles',
    'totalStep', 'visible', 'zLevel']
  const oid = getOverlayKey(overlay['id'])
  overlays.update(ol => {
    ol[oid] = Object.fromEntries(keys.map(k => [k, overlay[k]]))
    return ol
  })
}

const clickChart = derived(ctx, ($ctx) => $ctx.clickChart);
clickChart.subscribe(() => {
  popoverKey = ''
})

const cloudIndLoaded = derived(ctx, ($ctx) => $ctx.cloudIndLoaded);
cloudIndLoaded.subscribe(() => {
  const currentPrefix = getOverlayKey('')
  Object.entries($overlays).forEach(([key, v]) => {
    if (key.startsWith(currentPrefix)) {
      addOverlay(v)
    }
  })
})

// Global mouse event listeners for drag functionality
onMount(() => {
  loadSavedPosition()
  if (typeof document !== 'undefined') {
    document.addEventListener('mousemove', onMouseMove)
    document.addEventListener('mouseup', stopDrag)
  }
})

onDestroy(() => {
  if (typeof document !== 'undefined') {
    document.removeEventListener('mousemove', onMouseMove)
    document.removeEventListener('mouseup', stopDrag)
  }
})
</script>

{#snippet DrawButton(onClick: () => void, icon: string, itemKey: string = '', subItems: {key: string, text: string}[] = [])}
  <div class="group flex flex-row items-center justify-center relative w-full mt-2 cursor-pointer text-base-content/70">
    <span class="w-8 h-8 hover:text-primary" onclick={onClick}>
      <KlineIcon name={icon} active={itemKey === 'mode' && mode === modeIcon}/>
    </span>
    {#if subItems.length > 0}
      <div 
        class="flex flex-row items-center justify-center absolute top-0 right-0 h-8 w-[10px] opacity-0 group-hover:opacity-100 hover:opacity-100 transition-all duration-200 rounded-l hover:bg-base-200 z-10"
        onclick={() => clickPopoverKey(itemKey)}
      >
        <svg class:rotate-180={popoverKey === icon} class="w-1 h-1.5 transition-all duration-200 arrow-icon" viewBox="0 0 4 6">
          <path d="M1.07298,0.159458C0.827521,-0.0531526,0.429553,-0.0531526,0.184094,0.159458C-0.0613648,0.372068,-0.0613648,0.716778,0.184094,0.929388L2.61275,3.03303L0.260362,5.07061C0.0149035,5.28322,0.0149035,5.62793,0.260362,5.84054C0.505822,6.05315,0.903789,6.05315,1.14925,5.84054L3.81591,3.53075C4.01812,3.3556,4.05374,3.0908,3.92279,2.88406C3.93219,2.73496,3.87113,2.58315,3.73964,2.46925L1.07298,0.159458Z" stroke="none" stroke-opacity="0"/>
        </svg>
      </div>
      {#if itemKey === popoverKey}
        <ul class="absolute top-0 left-[calc(100%+1px)] whitespace-nowrap z-50 shadow-xl min-h-0" style="background-color: var(--popover-background-color); border: 1px solid var(--border-color);">
          {#each subItems as data}
            <li class="px-4 flex flex-row items-center h-10" 
              style="color: var(--text-color); background-color: transparent;"
              onmouseenter={(e) => (e.target as HTMLElement).style.backgroundColor = 'var(--selected-color)'}
              onmouseleave={(e) => (e.target as HTMLElement).style.backgroundColor = 'transparent'}
              onclick={() => itemKey === 'mode' ? clickSubMode(data.key) : clickSubPopover(subMenu.findIndex(i => i.key === itemKey), data.key)}>
              <KlineIcon name={data.key}/>
              <span class="pl-2">{m[data.text as keyof typeof m]()}</span>
            </li>
          {/each}
        </ul>
      {/if}
    {/if}
  </div>
{/snippet}

{#snippet Divider()}
  <div class="w-full h-px bg-base-content/20 mt-2"></div>
{/snippet}

<div class="w-[48px] h-full box-border border-r border-base-content/20" onclick={(e) => e.stopPropagation()}>
  {#each subMenu as item}
    {@render DrawButton(() => startOverlay(item.icon), item.icon, item.key, item.list)}
  {/each}
  
  {@render Divider()}
  
  {@render DrawButton(() => startOverlay('ruler'), 'ruler')}
  
  {@render Divider()}
  
  {@render DrawButton(clickMode, modeIcon, 'mode', modes)}
  
  {@render Divider()}
  
  {@render DrawButton(toggleLock, lock ? 'lock' : 'unlock')}
  
  {@render Divider()}
  
  {@render DrawButton(toggleVisiable, visiable ? 'visible' : 'invisible')}
  
  {@render Divider()}
  
  {@render DrawButton(clickRemove, 'remove')}
</div>

<!-- Minimalist Context menu for selected drawing -->
{#if showContextMenu && contextMenuPosition}
  <div 
    class="context-menu-container fixed z-50 rounded-lg shadow-lg px-3 py-2
           dark:bg-[#2A2A2A] dark:border-[#404040] 
           bg-white border border-gray-200 {isDragging ? 'cursor-grabbing' : ''}"
    style="left: {contextMenuPosition.x}px; 
           top: {contextMenuPosition.y}px;"
    onclick={(e) => e.stopPropagation()}
  >
    
    <!-- Minimalist horizontal toolbar -->
    <div class="flex items-center gap-4">
      <!-- Drag handle with 6 dots design -->
      <div 
        class="drag-handle cursor-grab hover:cursor-grabbing flex items-center justify-center w-6 h-6 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
        onmousedown={startDrag}
        title="Drag to move"
      >
        <div class="flex flex-col gap-0.5">
          <div class="flex gap-0.5">
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
          </div>
          <div class="flex gap-0.5">
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
          </div>
          <div class="flex gap-0.5">
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
            <div class="w-1 h-1 bg-gray-400 dark:bg-gray-500 rounded-full"></div>
          </div>
        </div>
      </div>
      <!-- Color picker button -->
      <button 
        class="w-8 h-8 rounded border-2 border-gray-300 dark:border-gray-600 cursor-pointer hover:scale-110 transition-transform"
        style="background-color: {contextMenuStyles.color};"
        onclick={openColorPicker}
        title="Choose color"
      ></button>
      
      <!-- Thickness with visual indicator -->
      <div class="flex items-center gap-2">
        <input 
          type="range" 
          min="1" 
          max="8" 
          bind:value={contextMenuStyles.thickness}
          oninput={updateOverlayStyles}
          class="w-20 h-1 dark:bg-gray-600 bg-gray-300 rounded appearance-none cursor-pointer"
        />
        <span class="text-xs dark:text-gray-300 text-gray-600 min-w-[24px]">{contextMenuStyles.thickness}px</span>
      </div>
      
      <!-- Line style dropdown -->
      <select 
        bind:value={contextMenuStyles.style}
        onchange={updateOverlayStyles}
        class="px-2 py-1 text-sm border rounded cursor-pointer
               dark:bg-[#2C2C2C] dark:border-[#3A3A3A] dark:text-white
               bg-white border-gray-300 text-gray-900"
      >
        <option value="solid">Line</option>
        <option value="dashed">Dashed</option>
        <option value="dotted">Dotted</option>
      </select>
      
      <!-- Delete button -->
      <button 
        class="w-8 h-8 rounded hover:bg-red-100 dark:hover:bg-red-900 transition-colors duration-200
               flex items-center justify-center"
        onclick={() => { clickRemove(); showContextMenu = false; selectedOverlayCoords = null; }}
        title="Delete"
      >
        <svg class="w-4 h-4 text-gray-600 dark:text-gray-300 hover:text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
        </svg>
      </button>
    </div>
  </div>
{/if}

<!-- Delete button overlay for selected drawing -->
{#if showDeleteButton && selectedOverlayCoords}
  <div 
    class="fixed z-50 bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center cursor-pointer shadow-lg transition-all duration-200"
    style="left: {selectedOverlayCoords.x}px; top: {selectedOverlayCoords.y}px;"
    onclick={clickRemove}
    title="Delete selected drawing"
  >
    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
    </svg>
  </div>
{/if}

<!-- Advanced Color Picker -->
<ColorPicker 
  bind:selectedColor={contextMenuStyles.color}
  bind:show={showColorPicker}
  bind:position={colorPickerPosition}
  on:colorChange={handleColorChange}
  on:opacityChange={handleOpacityChange}
  on:close={closeColorPicker}
/>

<style>
  .arrow-icon path {
    fill: #333333;
  }
  
  :global([data-theme="dark"]) .arrow-icon path {
    fill: white;
  }
  
  :global([data-theme="light"]) .arrow-icon path {
    fill: #333333;
  }
</style>
